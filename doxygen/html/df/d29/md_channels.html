<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcopp: Channel/Receiver Pattern</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libcopp<span id="projectnumber">&#160;2.3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Channel/Receiver Pattern</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Channels provide a powerful communication mechanism between coroutines in libcopp. They enable producer-consumer patterns and synchronization between both stackful and stackless (C++20) coroutines.</p>
<h1>Overview</h1>
<p>The channel/receiver pattern in libcopp allows coroutines to send and receive values asynchronously:</p>
<ul>
<li><b>Sender</b>: Produces values and sends them through a channel</li>
<li><b>Receiver</b>: Waits for and receives values from a channel</li>
<li><b>Channel</b>: The communication medium connecting senders and receivers</li>
</ul>
<p>Channels support:</p>
<ul>
<li>✅ <b>Producer/Consumer patterns</b>: One-to-one communication</li>
<li>✅ <b>Value transmission</b>: Send any copyable/movable type</li>
<li>✅ <b>Void channels</b>: Signal-only communication (no value)</li>
<li>✅ <b>Error handling</b>: Custom error transformations</li>
<li>✅ <b>Both coroutine types</b>: Stackful and stackless coroutines</li>
</ul>
<p><b>Note</b>: Channels do NOT support true broadcasting/multicasting. While multiple coroutines can wait on the same receiver, they share the underlying context. When one receiver calls <code>reset_value()</code>, it affects all receivers sharing that context.</p>
<hr  />
<h1>Stackful Coroutine Channels</h1>
<p>Stackful channels work with <code>cotask::task</code> and <code>copp::coroutine_context</code>.</p>
<h2>API Reference</h2>
<h3>Creating a Channel</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/dce/stackful__channel_8h.html">libcopp/coroutine/stackful_channel.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [receiver, sender] = copp::make_stackful_channel&lt;int&gt;();</div>
<div class="ttc" id="astackful__channel_8h_html"><div class="ttname"><a href="../../d2/dce/stackful__channel_8h.html">stackful_channel.h</a></div></div>
</div><!-- fragment --><p><b>Returns</b>: A pair of <code><a class="el" href="../../dd/d39/classstackful__channel__receiver.html">stackful_channel_receiver</a>&lt;T&gt;</code> and <code><a class="el" href="../../d1/df1/classstackful__channel__sender.html">stackful_channel_sender</a>&lt;T&gt;</code></p>
<h3><code><a class="el" href="../../dd/d39/classstackful__channel__receiver.html">stackful_channel_receiver</a>&lt;T&gt;</code></h3>
<p>The receiver waits for values from the channel.</p>
<p><b>Methods</b>:</p>
<ul>
<li><code>void reset_value()</code>: Reset the receiver to receive the next value</li>
<li><code>bool is_ready() const</code>: Check if a value is ready</li>
<li><code>bool is_pending() const</code>: Check if waiting for a value</li>
</ul>
<p><b>Usage with <code>cotask::task::await_value()</code></b>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="../../dc/d82/classconsumer__action.html">consumer_action</a> : <span class="keyword">public</span> cotask::impl::task_action_impl {</div>
<div class="line">  copp::stackful_channel_receiver&lt;int&gt; <a class="code hl_variable" href="../../dc/d82/classconsumer__action.html#a3ba2db778db9b3def3e0f34cd7182188">receiver_</a>;</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_function" href="../../dc/d82/classconsumer__action.html#a1d42b018eb51973cf6d87cb202531050">operator()</a>(<span class="keywordtype">void</span>*)<span class="keyword"> override </span>{</div>
<div class="line">    <span class="comment">// Wait for and receive a value</span></div>
<div class="line">    <span class="keywordtype">int</span> value = cotask::task&lt;&gt;::this_task()-&gt;await_value(<a class="code hl_variable" href="../../dc/d82/classconsumer__action.html#a3ba2db778db9b3def3e0f34cd7182188">receiver_</a>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Reset for next value</span></div>
<div class="line">    <a class="code hl_variable" href="../../dc/d82/classconsumer__action.html#a3ba2db778db9b3def3e0f34cd7182188">receiver_</a>.reset_value();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="aclassconsumer__action_html"><div class="ttname"><a href="../../dc/d82/classconsumer__action.html">consumer_action</a></div><div class="ttdef"><b>Definition</b> <a href="../../d2/da2/sample__readme__13_8cpp_source.html#l00043">sample_readme_13.cpp:43</a></div></div>
<div class="ttc" id="aclassconsumer__action_html_a1d42b018eb51973cf6d87cb202531050"><div class="ttname"><a href="../../dc/d82/classconsumer__action.html#a1d42b018eb51973cf6d87cb202531050">consumer_action::operator()</a></div><div class="ttdeci">int operator()(void *) override</div><div class="ttdef"><b>Definition</b> <a href="../../d2/da2/sample__readme__13_8cpp_source.html#l00047">sample_readme_13.cpp:47</a></div></div>
<div class="ttc" id="aclassconsumer__action_html_a3ba2db778db9b3def3e0f34cd7182188"><div class="ttname"><a href="../../dc/d82/classconsumer__action.html#a3ba2db778db9b3def3e0f34cd7182188">consumer_action::receiver_</a></div><div class="ttdeci">copp::stackful_channel_receiver&lt; int &gt; receiver_</div><div class="ttdef"><b>Definition</b> <a href="../../d2/da2/sample__readme__13_8cpp_source.html#l00068">sample_readme_13.cpp:68</a></div></div>
</div><!-- fragment --><p><b>With error transform</b>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> error_transform = [](copp::copp_error_code err) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(err) &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> -1;  <span class="comment">// Default value on error</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> value = cotask::task&lt;&gt;::this_task()-&gt;await_value(receiver_, error_transform);</div>
</div><!-- fragment --><p><b>Usage with <code>inject_await()</code> for low-level control</b>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> consumer_runner(<span class="keywordtype">void</span>* data_ptr) {</div>
<div class="line">  <span class="keyword">auto</span>* receiver = <span class="keyword">static_cast&lt;</span>copp::stackful_channel_receiver&lt;int&gt;*<span class="keyword">&gt;</span>(data_ptr);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Get current coroutine context</span></div>
<div class="line">  <span class="keyword">auto</span>* ctx = copp::this_coroutine::get&lt;copp::coroutine_context&gt;();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Directly await on receiver</span></div>
<div class="line">  <span class="keyword">auto</span> error_transform = [](copp::copp_error_code err) { <span class="keywordflow">return</span> 0; };</div>
<div class="line">  <span class="keywordtype">int</span> value = receiver-&gt;inject_await(ctx, error_transform);</div>
<div class="line">  </div>
<div class="line">  receiver-&gt;reset_value();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><code><a class="el" href="../../d1/df1/classstackful__channel__sender.html">stackful_channel_sender</a>&lt;T&gt;</code></h3>
<p>The sender sends values through the channel.</p>
<p><b>Methods</b>:</p>
<ul>
<li><code>void set_value(T&amp;&amp; value)</code>: Send a value through the channel</li>
<li><code>void set_value(const T&amp; value)</code>: Send a value through the channel</li>
</ul>
<p><b>Usage</b>:</p>
<div class="fragment"><div class="line">copp::stackful_channel_sender&lt;int&gt; sender = <span class="comment">/* ... */</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send a value</span></div>
<div class="line">sender.set_value(42);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// All waiting receivers will be resumed</span></div>
</div><!-- fragment --><h2>Complete Example</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/dce/stackful__channel_8h.html">libcopp/coroutine/stackful_channel.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../db/da4/task_8h.html">libcotask/task.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="../../db/d06/classproducer__action.html">producer_action</a> : <span class="keyword">public</span> cotask::impl::task_action_impl {</div>
<div class="line">  copp::stackful_channel_sender&lt;int&gt; <a class="code hl_variable" href="../../db/d06/classproducer__action.html#ac2e20b4098eedec1e2ab8b78d128f234">sender_</a>;</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_function" href="../../db/d06/classproducer__action.html#a003eaae8a3e5d8a4e98fdc76c6e194e1">operator()</a>(<span class="keywordtype">void</span>*)<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 5; ++i) {</div>
<div class="line">      <a class="code hl_variable" href="../../db/d06/classproducer__action.html#ac2e20b4098eedec1e2ab8b78d128f234">sender_</a>.set_value(i * 100);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="../../dc/d82/classconsumer__action.html">consumer_action</a> : <span class="keyword">public</span> cotask::impl::task_action_impl {</div>
<div class="line">  copp::stackful_channel_receiver&lt;int&gt; <a class="code hl_variable" href="../../dc/d82/classconsumer__action.html#a3ba2db778db9b3def3e0f34cd7182188">receiver_</a>;</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_function" href="../../dc/d82/classconsumer__action.html#a1d42b018eb51973cf6d87cb202531050">operator()</a>(<span class="keywordtype">void</span>*)<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 5; ++i) {</div>
<div class="line">      <span class="keywordtype">int</span> value = cotask::task&lt;&gt;::this_task()-&gt;await_value(<a class="code hl_variable" href="../../dc/d82/classconsumer__action.html#a3ba2db778db9b3def3e0f34cd7182188">receiver_</a>);</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</div>
<div class="line">      <a class="code hl_variable" href="../../dc/d82/classconsumer__action.html#a3ba2db778db9b3def3e0f34cd7182188">receiver_</a>.reset_value();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../dd/da3/crosscompiling-upb-host_2client-main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">  <span class="keyword">auto</span> [receiver, sender] = copp::make_stackful_channel&lt;int&gt;();</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> consumer = cotask::task&lt;&gt;::create(<a class="code hl_class" href="../../dc/d82/classconsumer__action.html">consumer_action</a>(std::move(receiver)));</div>
<div class="line">  <span class="keyword">auto</span> producer = cotask::task&lt;&gt;::create(<a class="code hl_class" href="../../db/d06/classproducer__action.html">producer_action</a>(std::move(sender)));</div>
<div class="line">  </div>
<div class="line">  consumer-&gt;start();</div>
<div class="line">  producer-&gt;start();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassproducer__action_html"><div class="ttname"><a href="../../db/d06/classproducer__action.html">producer_action</a></div><div class="ttdef"><b>Definition</b> <a href="../../d2/da2/sample__readme__13_8cpp_source.html#l00016">sample_readme_13.cpp:16</a></div></div>
<div class="ttc" id="aclassproducer__action_html_a003eaae8a3e5d8a4e98fdc76c6e194e1"><div class="ttname"><a href="../../db/d06/classproducer__action.html#a003eaae8a3e5d8a4e98fdc76c6e194e1">producer_action::operator()</a></div><div class="ttdeci">int operator()(void *) override</div><div class="ttdef"><b>Definition</b> <a href="../../d2/da2/sample__readme__13_8cpp_source.html#l00020">sample_readme_13.cpp:20</a></div></div>
<div class="ttc" id="aclassproducer__action_html_ac2e20b4098eedec1e2ab8b78d128f234"><div class="ttname"><a href="../../db/d06/classproducer__action.html#ac2e20b4098eedec1e2ab8b78d128f234">producer_action::sender_</a></div><div class="ttdeci">copp::stackful_channel_sender&lt; int &gt; sender_</div><div class="ttdef"><b>Definition</b> <a href="../../d2/da2/sample__readme__13_8cpp_source.html#l00039">sample_readme_13.cpp:39</a></div></div>
<div class="ttc" id="acrosscompiling-upb-host_2client-main_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="../../dd/da3/crosscompiling-upb-host_2client-main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> <a href="../../dd/da3/crosscompiling-upb-host_2client-main_8cpp_source.html#l00013">client-main.cpp:13</a></div></div>
<div class="ttc" id="atask_8h_html"><div class="ttname"><a href="../../db/da4/task_8h.html">task.h</a></div></div>
</div><!-- fragment --><p><b>See</b>: <a href="https://github.com/owent/libcopp/blob/v2/sample/sample_readme_13.cpp">sample/sample_readme_13.cpp</a> for full examples including:</p><ul>
<li>Basic producer/consumer</li>
<li>Error handling with custom transforms</li>
<li>Direct usage with <code>copp::coroutine_context</code></li>
</ul>
<hr  />
<h1>C++20 Coroutine Channels</h1>
<p>Stackless channels work with C++20 coroutines (<code>copp::callable_future</code>, <code>copp::generator_future</code>).</p>
<h2>API Reference</h2>
<h3>Creating a Channel</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d4a/generator__promise_8h.html">libcopp/coroutine/generator_promise.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [receiver, sender] = copp::make_channel&lt;int&gt;();</div>
<div class="ttc" id="agenerator__promise_8h_html"><div class="ttname"><a href="../../d2/d4a/generator__promise_8h.html">generator_promise.h</a></div></div>
</div><!-- fragment --><p><b>Returns</b>: A pair of <code>generator_channel_receiver&lt;T&gt;</code> and <code>generator_channel_sender&lt;T&gt;</code></p>
<p><b>Types</b>:</p><ul>
<li><code>generator_channel_receiver&lt;T, ErrorTransform&gt;</code>: Alias for <code>generator_channel_future&lt;T, ErrorTransform&gt;</code></li>
<li><code>generator_channel_sender&lt;T, ErrorTransform&gt;</code>: A smart pointer (<code>context_pointer_type</code>) to the channel context</li>
</ul>
<h3><code>generator_channel_receiver&lt;T, ErrorTransform&gt;</code></h3>
<p>The receiver is an awaitable that suspends the coroutine until a value is available.</p>
<p><b>Template Parameters</b>:</p><ul>
<li><code>T</code>: Value type (use <code>void</code> for signal-only channels)</li>
<li><code>ErrorTransform</code>: Error transform functor (default: <code>promise_error_transform&lt;T&gt;</code>)</li>
</ul>
<p><b>Methods</b>:</p><ul>
<li><code>void reset_value()</code>: Reset the receiver to receive the next value</li>
<li><code>bool is_ready() const</code>: Check if a value is ready</li>
<li><code>bool is_pending() const</code>: Check if waiting for a value</li>
<li><code>promise_status get_status() const</code>: Get current status</li>
</ul>
<p><b>Usage with <code>co_await</code></b>:</p>
<div class="fragment"><div class="line">copp::callable_future&lt;int&gt; consumer(copp::generator_channel_receiver&lt;int&gt; receiver) {</div>
<div class="line">  <span class="comment">// Suspend until value is available</span></div>
<div class="line">  <span class="keywordtype">int</span> value = <span class="keyword">co_await</span> receiver;</div>
<div class="line">  </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Reset for next value</span></div>
<div class="line">  receiver.reset_value();</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">co_return</span> value;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>For <code>void</code> channels</b>:</p>
<div class="fragment"><div class="line">copp::callable_future&lt;void&gt; consumer(copp::generator_channel_receiver&lt;void&gt; receiver) {</div>
<div class="line">  <span class="comment">// Wait for signal</span></div>
<div class="line">  <span class="keyword">co_await</span> receiver;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Signal received!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  </div>
<div class="line">  receiver.reset_value();</div>
<div class="line">  <span class="keyword">co_return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><code>generator_channel_sender&lt;T, ErrorTransform&gt;</code></h3>
<p>The sender is a smart pointer to the channel context.</p>
<p><b>Methods</b>:</p><ul>
<li><code>void set_value(T&amp;&amp; value)</code>: Send a value (for non-void channels)</li>
<li><code>void set_value(const T&amp; value)</code>: Send a value (for non-void channels)</li>
<li><code>void set_value()</code>: Send a signal (for void channels)</li>
</ul>
<p><b>Usage</b>:</p>
<div class="fragment"><div class="line">copp::generator_channel_sender&lt;int&gt; sender = <span class="comment">/* ... */</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send a value</span></div>
<div class="line">sender-&gt;set_value(42);  <span class="comment">// Note: use -&gt; operator</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// All waiting coroutines will be resumed</span></div>
</div><!-- fragment --><h3>Custom Error Transform</h3>
<p>Define custom error handling for channel operations:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>custom_error_transform {</div>
<div class="line">  <span class="keywordtype">int</span> operator()(copp::promise_status status)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">if</span> (status == copp::promise_status::kKilled) {</div>
<div class="line">      <span class="keywordflow">return</span> -999;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status == copp::promise_status::kTimeout) {</div>
<div class="line">      <span class="keywordflow">return</span> -888;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [receiver, sender] = copp::make_channel&lt;int, custom_error_transform&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> consumer_future = consumer(std::move(receiver));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Kill the consumer to trigger error transform</span></div>
<div class="line">consumer_future.kill(copp::promise_status::kKilled, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// consumer_future.get_internal_promise().data() == -999</span></div>
</div><!-- fragment --><h2>Complete Example</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../da/daf/callable__promise_8h.html">libcopp/coroutine/callable_promise.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d4a/generator__promise_8h.html">libcopp/coroutine/generator_promise.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">copp::callable_future&lt;void&gt; producer(copp::generator_channel_sender&lt;int&gt; sender, <span class="keywordtype">int</span> count) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= count; ++i) {</div>
<div class="line">    sender-&gt;set_value(i * 100);</div>
<div class="line">    <span class="keyword">co_await</span> copp::callable_future&lt;void&gt;::yield();</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">co_return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">copp::callable_future&lt;int&gt; consumer(copp::generator_channel_receiver&lt;int&gt; receiver, <span class="keywordtype">int</span> count) {</div>
<div class="line">  <span class="keywordtype">int</span> sum = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= count; ++i) {</div>
<div class="line">    <span class="keywordtype">int</span> value = <span class="keyword">co_await</span> receiver;</div>
<div class="line">    sum += value;</div>
<div class="line">    receiver.reset_value();</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">co_return</span> sum;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../dd/da3/crosscompiling-upb-host_2client-main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">  <span class="keyword">auto</span> [receiver, sender] = copp::make_channel&lt;int&gt;();</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> consumer_future = consumer(std::move(receiver), 5);</div>
<div class="line">  <span class="keyword">auto</span> producer_future = producer(sender, 5);</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">int</span> total = consumer_future.get_internal_promise().data();</div>
<div class="line">  <span class="comment">// total == 1500 (100 + 200 + 300 + 400 + 500)</span></div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="acallable__promise_8h_html"><div class="ttname"><a href="../../da/daf/callable__promise_8h.html">callable_promise.h</a></div></div>
</div><!-- fragment --><p><b>See</b>: <a href="https://github.com/owent/libcopp/blob/v2/sample/sample_readme_14.cpp">sample/sample_readme_14.cpp</a> for full examples including:</p><ul>
<li>Basic channel usage</li>
<li>Producer/consumer pattern</li>
<li>Error handling with custom transforms</li>
<li>Void channels for signaling</li>
<li>Comparison of generator vtable types</li>
</ul>
<hr  />
<h1>Usage Patterns</h1>
<h2>Producer/Consumer</h2>
<p>One producer sends values, one consumer receives them.</p>
<p><b>Best for</b>: Pipeline processing, task queues</p>
<div class="fragment"><div class="line"><span class="comment">// Stackful</span></div>
<div class="line"><span class="keyword">auto</span> [receiver, sender] = copp::make_stackful_channel&lt;int&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// C++20</span></div>
<div class="line"><span class="keyword">auto</span> [receiver, sender] = copp::make_channel&lt;int&gt;();</div>
</div><!-- fragment --><h2>Signal-only Communication</h2>
<p>Use <code>void</code> channels when you only need to signal events without data.</p>
<p><b>Best for</b>: Synchronization, wake-up notifications</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [receiver, sender] = copp::make_channel&lt;void&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sender</span></div>
<div class="line">sender-&gt;set_value();  <span class="comment">// Send signal</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Receiver</span></div>
<div class="line"><span class="keyword">co_await</span> receiver;  <span class="comment">// Wait for signal</span></div>
</div><!-- fragment --><hr  />
<h1>Generator VTable Types (C++20 Only)</h1>
<p>libcopp provides three generator vtable types for different performance/flexibility tradeoffs:</p>
<h2><code>generator_vtable_type::kDefault</code></h2>
<p><b>Type</b>: <code>copp::generator_future&lt;T&gt;</code></p>
<ul>
<li>Uses <code>std::function</code> for callbacks</li>
<li>Most flexible - can capture complex state</li>
<li>Higher overhead due to type erasure</li>
<li><b>Best for</b>: Complex scenarios with stateful callbacks</li>
</ul>
<div class="fragment"><div class="line">copp::generator_future&lt;int&gt; <a class="code hl_namespace" href="../../dc/d0c/namespacefuture.html">future</a>{</div>
<div class="line">  [captured_state](copp::generator_future&lt;int&gt;::context_pointer_type ctx) {</div>
<div class="line">    <span class="comment">// Can capture complex state</span></div>
<div class="line">  },</div>
<div class="line">  [](<span class="keyword">const</span> copp::generator_future&lt;int&gt;::context_type&amp; ctx) {</div>
<div class="line">    <span class="comment">// Resume callback</span></div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="anamespacefuture_html"><div class="ttname"><a href="../../dc/d0c/namespacefuture.html">future</a></div><div class="ttdef"><b>Definition</b> <a href="../../d9/d4a/future_8h_source.html#l00018">future.h:18</a></div></div>
</div><!-- fragment --><h2><code>generator_vtable_type::kLightWeight</code></h2>
<p><b>Type</b>: <code>copp::generator_lightweight_future&lt;T&gt;</code></p>
<ul>
<li>Uses function pointers instead of <code>std::function</code></li>
<li>Lower overhead, faster performance</li>
<li>Cannot capture state in callbacks</li>
<li><b>Best for</b>: Performance-critical code with simple callbacks</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> on_suspend(copp::generator_lightweight_future&lt;int&gt;::context_pointer_type ctx) {</div>
<div class="line">  <span class="comment">// Function pointer - no captures</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">copp::generator_lightweight_future&lt;int&gt; <a class="code hl_namespace" href="../../dc/d0c/namespacefuture.html">future</a>{on_suspend};</div>
</div><!-- fragment --><h2><code>generator_vtable_type::kNone</code></h2>
<p><b>Type</b>: <code>copp::generator_channel_future&lt;T&gt;</code> (used by <code>make_channel()</code>)</p>
<ul>
<li>No callbacks - designed for channel pattern</li>
<li>Minimal overhead, most efficient</li>
<li><b>Best for</b>: Channel-based communication</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [receiver, sender] = copp::make_channel&lt;int&gt;();</div>
<div class="line"><span class="comment">// receiver is generator_channel_future&lt;int&gt;</span></div>
</div><!-- fragment --><h2>Recommendation</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Use Case   </th><th class="markdownTableHeadNone">Recommended Type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Channel communication   </td><td class="markdownTableBodyNone"><code>make_channel()</code> (kNone)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Simple futures   </td><td class="markdownTableBodyNone"><code>generator_lightweight_future</code> (kLightWeight)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Complex futures with state   </td><td class="markdownTableBodyNone"><code>generator_future</code> (kDefault)   </td></tr>
</table>
<hr  />
<h1>Performance Considerations</h1>
<h2>When to Use Stackful vs Stackless</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature   </th><th class="markdownTableHeadNone">Stackful Channels   </th><th class="markdownTableHeadNone">Stackless Channels (C++20)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Stack usage</b>   </td><td class="markdownTableBodyNone">Allocates stack per coroutine   </td><td class="markdownTableBodyNone">No stack allocation    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Compatibility</b>   </td><td class="markdownTableBodyNone">Works on all C++11+ compilers   </td><td class="markdownTableBodyNone">Requires C++20 support    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Integration</b>   </td><td class="markdownTableBodyNone">Works with existing callback APIs   </td><td class="markdownTableBodyNone">Better with async/await code    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Performance</b>   </td><td class="markdownTableBodyNone">Slightly higher overhead   </td><td class="markdownTableBodyNone">Lower overhead    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Debugging</b>   </td><td class="markdownTableBodyNone">Easier to debug stack traces   </td><td class="markdownTableBodyNone">Harder to debug state machines   </td></tr>
</table>
<p><b>Recommendation</b>:</p><ul>
<li>Use <b>stackful</b> if you need C++11/14/17 compatibility or work with callback-heavy code</li>
<li>Use <b>stackless</b> if you have C++20 and want modern async/await syntax</li>
</ul>
<h2>Channel Best Practices</h2>
<ol type="1">
<li><b>Always <code>reset_value()</code> after receiving</b> <div class="fragment"><div class="line"><span class="keywordtype">int</span> value = <span class="keyword">co_await</span> receiver;</div>
<div class="line">receiver.reset_value();  <span class="comment">// Required for next receive</span></div>
</div><!-- fragment --></li>
<li><b>Avoid blocking senders</b><ul>
<li>Channels don't buffer values</li>
<li>Sender resumes all waiting receivers immediately</li>
<li>If no receivers are waiting, the value is stored until next <code>co_await</code></li>
</ul>
</li>
<li><b>Error handling</b><ul>
<li>Always provide error transforms for production code</li>
<li>Handle <code>promise_status::kKilled</code> and <code>kTimeout</code> cases</li>
<li>Default error transform returns default-constructed value</li>
</ul>
</li>
</ol>
<hr  />
<h1>Common Pitfalls</h1>
<h2>Forgetting to Reset</h2>
<div class="fragment"><div class="line"><span class="comment">// ❌ Wrong</span></div>
<div class="line"><span class="keywordtype">int</span> v1 = <span class="keyword">co_await</span> receiver;</div>
<div class="line"><span class="keywordtype">int</span> v2 = <span class="keyword">co_await</span> receiver;  <span class="comment">// Returns same value!</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ Correct</span></div>
<div class="line"><span class="keywordtype">int</span> v1 = <span class="keyword">co_await</span> receiver;</div>
<div class="line">receiver.reset_value();</div>
<div class="line"><span class="keywordtype">int</span> v2 = <span class="keyword">co_await</span> receiver;</div>
</div><!-- fragment --><h2>Sender Access Pattern Difference</h2>
<div class="fragment"><div class="line"><span class="comment">// Stackful</span></div>
<div class="line">copp::stackful_channel_sender&lt;int&gt; sender;</div>
<div class="line">sender.set_value(42);  <span class="comment">// Direct method call</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Stackless (C++20)</span></div>
<div class="line">copp::generator_channel_sender&lt;int&gt; sender;  <span class="comment">// This is a smart pointer</span></div>
<div class="line">sender-&gt;set_value(42);  <span class="comment">// Use -&gt; operator</span></div>
</div><!-- fragment --><h2>Not Handling Errors</h2>
<div class="fragment"><div class="line"><span class="comment">// ❌ Without error handling</span></div>
<div class="line"><span class="keywordtype">int</span> value = <span class="keyword">co_await</span> receiver;  <span class="comment">// May return default value on error</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ With error handling</span></div>
<div class="line"><span class="keyword">auto</span> [receiver, sender] = copp::make_channel&lt;int, custom_error_transform&gt;();</div>
</div><!-- fragment --><hr  />
<h1>See Also</h1>
<ul>
<li><a class="el" href="../../d6/d3f/md_examples_2index.html">Examples</a> - Full working examples</li>
<li><a href="https://github.com/owent/libcopp/blob/v2/sample/sample_readme_13.cpp">sample_readme_13.cpp</a> - Stackful channel examples</li>
<li><a href="https://github.com/owent/libcopp/blob/v2/sample/sample_readme_14.cpp">sample_readme_14.cpp</a> - C++20 channel examples</li>
<li><a href="../../doxygen/html/">API Reference</a> - Detailed API documentation </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
