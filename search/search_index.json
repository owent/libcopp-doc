{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"libcopp","text":"<p>Cross-platform coroutine library in C++.</p>"},{"location":"#ci-job-matrix","title":"CI Job Matrix","text":"Target System Toolchain Note Linux GCC Static linking Linux GCC Dynamic linking Linux GCC-latest Linux GCC-latest No Exception Linux GCC-latest Thread Unsafe Linux Clang-latest With libc++ MinGW64 GCC Dynamic linking Windows Visual Studio 2022 Static linking Windows Visual Studio 2022 Dynamic linking macOS AppleClang With libc++"},{"location":"#license","title":"License","text":"<p>License under the MIT LICENSE.</p>"},{"location":"#document","title":"Document","text":"<p>Documents can be found at https://libcopp.atframe.work, API references can be found at https://libcopp.atframe.work/doxygen/html/. (Generated by MkDocs with docs/mkdocs.yml and Doxygen with docs/libcopp.doxyfile.in.)</p>"},{"location":"#upgrade-from-13x-14x-to-2x","title":"UPGRADE FROM 1.3.X-1.4.X to 2.X","text":"<ul> <li>Add <code>using value_type = int;</code> into <code>T</code> when using <code>cotask::task&lt;T&gt;</code>.</li> <li>Rename <code>stack_allocator_t</code> to <code>stack_allocator_type</code> in <code>T</code> when using <code>cotask::task&lt;T&gt;</code>.</li> <li>Rename <code>coroutine_t</code> to <code>coroutine_type</code> in <code>T</code> when using <code>cotask::task&lt;T&gt;</code>.</li> <li>Rename <code>libcopp::util::*</code> to <code>copp::util::</code>.</li> <li>We are not allowed to use <code>libcopp::util::intrusive_ptr&lt;cotask::impl::task_impl&gt;</code> now, please use <code>cotask::task&lt;T&gt;::ptr_type</code> instead.</li> </ul>"},{"location":"#upgrade-from-12x-to-13x-14x","title":"UPGRADE FROM 1.2.X to 1.3.X-1.4.X","text":"<ul> <li>Rename <code>cotask::task::await</code> into <code>cotask::task::await_task</code>.</li> <li>Replace <code>cotask::task&lt;TCO_MACRO, TTASK_MACRO&gt;</code> with <code>cotask::task&lt;TCO_MACRO&gt;</code>, we don't allow to custom id allocator now.</li> <li>Replace <code>cotask::core::standard_int_id_allocator&lt;uint64_t&gt;</code> with <code>copp::util::uint64_id_allocator</code>, we don't allow to custom id allocator now.</li> <li>Require gcc 4.8+, MSVC 15+(Visual Studio 2017&gt;).</li> <li>Require cmake 3.12.0 or upper.</li> </ul>"},{"location":"#install","title":"INSTALL","text":"<p>libcopp use cmake to generate makefile and switch build tools.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>[required] GCC or Clang or MSVC or clang-cl support ISO C++ 11 and upper</li> <li>[required] cmake 3.16.0 and upper</li> <li>[optional] gtest 1.6.0 and upper (Better unit test supported)</li> <li>[optional] Boost.Test (Boost.Test supported)</li> </ul>"},{"location":"#unix","title":"Unix","text":"<ul> <li>[required] <code>ar, as, ld</code> (binutils) or llvm</li> <li>[optional] if using gtest, pthread is required.</li> </ul>"},{"location":"#windows","title":"Windows","text":"<ul> <li>[required] masm (in MSVC)</li> <li>[optional] if using gtest, pthread is required.</li> </ul>"},{"location":"#install-with-vcpkg","title":"Install with vcpkg","text":"<ol> <li>Clone and setup vcpkg (See more detail on https://github.com/Microsoft/vcpkg)</li> </ol> <pre><code>git clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\nPS&gt; bootstrap-vcpkg.bootstrap\nLinux:~/$ ./bootstrap-vcpkg.sh\n</code></pre> <ol> <li>Install libcopp</li> </ol> <pre><code>PS&gt; .\\vcpkg install libcopp [--triplet x64-windows-static/x64-windows/x64-windows-static-md and etc...]\nLinux:~/$ ./vcpkg install libcopp\n</code></pre> <ol> <li>See using with cmake for cmake below.</li> </ol>"},{"location":"#custom-build","title":"Custom Build","text":"<ol> <li>Clone and make a build directory</li> </ol> <pre><code>git clone --single-branch --depth=1 -b master https://github.com/owent/libcopp.git\nmkdir libcopp/build &amp;&amp; cd libcopp/build\n</code></pre> <ol> <li>Run cmake command</li> </ol> <pre><code># cmake &lt;libcopp dir&gt; [options...]\ncmake .. -DPROJECT_ENABLE_UNITTEST=YES -DPROJECT_ENABLE_SAMPLE=YES\n</code></pre> <ol> <li>Make libcopp</li> </ol> <pre><code>cmake --build . --config RelWithDebInfo # or make [options] when using Makefile\n</code></pre> <ol> <li>Run <code>test/sample/benchmark</code> [optional]</li> </ol> <pre><code># Run test =&gt; Required: PROJECT_ENABLE_UNITTEST=YES\nctest -VV . -C RelWithDebInfo -L libcopp.unit_test\n# Run sample =&gt; Required: PROJECT_ENABLE_SAMPLE=YES\nctest -VV . -C RelWithDebInfo -L libcopp.sample\n# Run benchmark =&gt; Required: PROJECT_ENABLE_SAMPLE=YES\nctest -VV . -C RelWithDebInfo -L libcopp.benchmark\n</code></pre> <ol> <li>Install [optional]</li> </ol> <pre><code>cmake --build . --config RelWithDebInfo --target install # or make install when using Makefile\n</code></pre> <ol> <li>Then just include and link <code>libcopp.*/libcotask.*</code>, or see using with cmake for cmake below.</li> </ol>"},{"location":"#cmake-options","title":"CMake Options","text":"<p>Options can be cmake options. such as set compile toolchains, source directory or options of libcopp that control build actions. libcopp options are listed below:</p> Option Description BUILD_SHARED_LIBS=YES|NO [default=NO] Build dynamic library. LIBCOPP_ENABLE_SEGMENTED_STACKS=YES|NO [default=NO] Enable split stack supported context.(it's only availabe in linux and gcc 4.7.0 or upper) LIBCOPP_ENABLE_VALGRIND=YES|NO [default=YES] Enable valgrind supported context. PROJECT_ENABLE_UNITTEST=YES|NO [default=NO] Build unit test. PROJECT_ENABLE_SAMPLE=YES|NO [default=NO] Build samples. LIBCOPP_ENABLE_MULTI_THREAD=YES|NO [default=YES] Enable multi-thread support. LIBCOTASK_ENABLE=YES|NO [default=YES] Enable build libcotask. LIBCOPP_FCONTEXT_USE_TSX=YES|NO [default=YES] Enable Intel Transactional Synchronisation Extensions (TSX). LIBCOPP_MACRO_TLS_STACK_PROTECTOR=YES|NO [default=NO] Users need set LIBCOPP_MACRO_TLS_STACK_PROTECTOR=ON when compiling with <code>-fstack-protector</code>. Because it changes the default context switching logic. GTEST_ROOT=[path] set gtest library install prefix path BOOST_ROOT=[path] set Boost.Test library install prefix path"},{"location":"#usage","title":"USAGE","text":""},{"location":"#using-with-cmake","title":"Using with cmake","text":"<ol> <li>Using <code>set(Libcopp_ROOT &lt;where to find libcopp/INSTALL_PREFIX&gt;)</code></li> <li>Just using find_package(Libcopp) to use libcopp module.</li> <li>Example:(we assume the target name is stored in <code>${CUSTOM_TARGET_NAME}</code>)</li> </ol> <pre><code>find_package(Libcopp CONFIG REQUIRED)\ntarget_link_libraries(${CUSTOM_TARGET_NAME} libcopp::cotask)\n# Or just using copp by target_link_libraries(${CUSTOM_TARGET_NAME} libcopp::copp)\n</code></pre> <p>If using MSVC and vcpkg, CRT must match the triplet of vcpkg, these codes below may be helpful:</p> <pre><code>if (MSVC AND VCPKG_TOOLCHAIN)\n    if(DEFINED ENV{VCPKG_DEFAULT_TRIPLET} AND NOT DEFINED VCPKG_TARGET_TRIPLET)\n        set(VCPKG_TARGET_TRIPLET \"$ENV{VCPKG_DEFAULT_TRIPLET}\" CACHE STRING \"\")\n    endif()\n    if (VCPKG_TARGET_TRIPLET MATCHES \"^.*windows-static$\")\n        set(CMAKE_MSVC_RUNTIME_LIBRARY \"MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;\" CACHE STRING \"\")\n    else ()\n        set(CMAKE_MSVC_RUNTIME_LIBRARY \"MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;DLL\" CACHE STRING \"\")\n    endif ()\nendif ()\n</code></pre> <p>See more detail on https://github.com/Microsoft/vcpkg/tree/master/ports/libcopp.</p>"},{"location":"#directly-use-headers-and-libraries","title":"Directly use headers and libraries","text":"<p>Just include headers and linking library file of your platform to use libcopp.</p> <pre><code>LIBCOPP_PREFIX=&lt;WHERE TO INSTALL libcopp&gt;\n\n# Example command for build sample with gcc 4.9 or upper on Linux\nfor source in sample_readme_*.cpp; do\n    g++ -std=c++14 -O2 -g -ggdb -Wall -Werror -fPIC -rdynamic -fdiagnostics-color=auto -Wno-unused-local-typedefs \\\n        -I$LIBCOPP_PREFIX/include -L$LIBCOPP_PREFIX/lib64 -lcopp -lcotask $source -o $source.exe;\ndone\n\n# Example command for build sample with clang 3.9 or upper and libc++ on Linux\nfor source in sample_readme_*.cpp; do\n    clang++ -std=c++17 -stdlib=libc++ -O2 -g -ggdb -Wall -Werror -fPIC -rdynamic \\\n        -I$LIBCOPP_PREFIX/include -L$LIBCOPP_PREFIX/lib64 -lcopp -lcotask -lc++ -lc++abi \\\n        $source -o $source.exe;\ndone\n\n# AppleClang on macOS just like those scripts upper.\n# If you are using MinGW on Windows, it's better to add -static-libstdc++ -static-libgcc to \n#     use static linking and other scripts are just like those on Linux.\n</code></pre> <pre><code># Example command for build sample with MSVC 1914 or upper on Windows &amp; powershell(Debug Mode /MDd)\nforeach ($source in Get-ChildItem -File -Name .\\sample_readme_*.cpp) {\n    cl /nologo /MP /W4 /wd\"4100\" /wd\"4125\" /EHsc /std:c++17 /Zc:__cplusplus /O2 /MDd /I$LIBCOPP_PREFIX/include $LIBCOPP_PREFIX/lib64/copp.lib $LIBCOPP_PREFIX/lib64/cotask.lib $source\n}\n</code></pre>"},{"location":"#get-start-example","title":"Get Start &amp; Example","text":"<p>There serveral samples to use <code>copp::coroutine_context</code>, <code>copp::coroutine_context_fiber</code> and <code>cotask::task</code>:</p> <ol> <li>Using coroutine context</li> <li>Using coroutine task</li> <li>Using coroutine task manager</li> <li>Using stack pool</li> <li>Using <code>task::then</code> or <code>task::await_task</code></li> <li>Using <code>copp::callable_promise</code> of c++20 coroutine</li> <li>Using <code>copp::generator_future</code> for c++20 coroutine</li> <li>Custom error (timeout for example) when using c++20 coroutine</li> <li>Let c++20 coroutine work with <code>cotask::task</code></li> <li>Using Windows fiber and <code>SetUnhandledExceptionFilter</code> on Windows with <code>cotask::task</code></li> <li>Using c++20 coroutine with channel receiver and sender</li> <li>Using stackful coroutine task with channel receiver and sender</li> <li>Using stackful coroutine with channel receiver and sender</li> <li>Using c++20 coroutine with channel receiver and sender</li> </ol> <p>All sample codes can be found on EXAMPLES and sample.</p>"},{"location":"#notice","title":"NOTICE","text":"<p>Split stack support: if in Linux and user gcc 4.7.0 or upper, add <code>-DLIBCOPP_ENABLE_SEGMENTED_STACKS=YES</code> to use split stack supported context.</p> <p>It's recommanded to use stack pool instead of gcc splited stack.</p>"},{"location":"#benchmark","title":"BENCHMARK","text":"<p>Please see CI output for latest benchmark report. Click to visit Github Actions.</p>"},{"location":"#faq","title":"FAQ","text":"<p>Q: How to enable c++20 coroutine</p> <p>ANS: Add <code>/std:c++latest /await</code> for MSVC 1932 and below or <code>-std=c++20 -fcoroutines-ts -stdlib=libc++</code> for clang 13 and below or <code>-std=c++20 -fcoroutines</code> for gcc 10.</p> <p>If you can just use <code>-std=c++20 -stdlib=libc++</code> clang 14 or above, <code>-astd=c++20</code> for gcc 11 or above, and <code>/std:c++latest</code> for MSVC 1932 or above.</p> <p>Q: Will libcopp handle exception?</p> <p>ANS: When using c++11 or above, libcopp will catch all unhandled exception and rethrow it after coroutine resumed.</p> <p>Q: Why <code>SetUnhandledExceptionFilter</code> can not catch the unhandled exception in a coroutine?</p> <p>ANS: <code>SetUnhandledExceptionFilter</code> only works with Windows Fiber, please see sample/sample_readme_11.cpp for details.</p>"},{"location":"#feedback","title":"FEEDBACK","text":"<p>If you has any question, please create a issue and provide the information of your environments. For example:</p> <ul> <li>OS: Windows 10 Pro 19041 (This can be see after running <code>msinfo32</code>) / Manjaro(Arch) Linux Linux 5.4.39-1-MANJARO</li> <li>Compiler: Visual Studio 2022 C++ 17.14.6 with VS 2022 C++ v14.38 or MSVC 1925/ gcc 9.3.0</li> <li>CMake Commands: <code>cmake .. -G \"Visual Studio 17 2022\" -A x64 -DLIBCOPP_FCONTEXT_USE_TSX=ON -DPROJECT_ENABLE_UNITTEST=ON -DPROJECT_ENABLE_SAMPLE=ON-DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_INSTALL_PREFIX=%cd%/install-prefix</code> / <code>cmake .. -G Ninja -DLIBCOPP_FCONTEXT_USE_TSX=ON -DPROJECT_ENABLE_UNITTEST=ON -DPROJECT_ENABLE_SAMPLE=ON -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_INSTALL_PREFIX=/opt/libcopp</code></li> <li>Compile Commands: <code>cmake --build . -j</code></li> <li>Related Environment Variables: Please provide all the environment variables which will change the cmake toolchain, <code>CC</code>, <code>CXX</code>, <code>AR</code> and etc.</li> </ul>"},{"location":"#contributors","title":"CONTRIBUTORS","text":"<ul> <li>owent</li> </ul>"},{"location":"#thanks-to","title":"THANKS TO","text":"<ul> <li>mutouyun</li> </ul>"},{"location":"changelog/","title":"CHANGELOG","text":""},{"location":"changelog/#232","title":"2.3.2","text":"<ol> <li>Rewrite document.</li> <li>Support cmake 4+.</li> </ol>"},{"location":"changelog/#231","title":"2.3.1","text":"<ol> <li>Fixes storage types in <code>generator_vtable</code>.</li> <li>Fixes format rule.</li> </ol>"},{"location":"changelog/#230","title":"2.3.0","text":"<ol> <li>Rename all macros <code>COPP_*</code> to <code>LIBCOPP_*</code> .</li> <li>Make all macros in compile_optimize.h and explicit_declare. standalone from atframework.</li> <li>Merge boost.fcontext 1.87.</li> <li>Remove <code>LIBCOPP_MACRO_HAS_EXCEPTION</code>.</li> <li>Add nostd type_traits and <code>strong_rc_ptr</code> for non thread-safety smart pointer.</li> <li>Remove <code>LIBCOPP_DISABLE_ATOMIC_LOCK</code>, <code>LIBCOPP_LOCK_DISABLE_THIS_MT</code> and <code>LIBCOPP_LOCK_DISABLE_MT</code>. We use the only one option <code>LIBCOPP_ENABLE_MULTI_THREAD</code> now.</li> <li>Allow to disable multi-thread support for stack pool and C++20 coroutine to reduce cache miss.</li> <li>We allow use lightweight callback or channel mode(without callback) for C++20 coroutine generator.</li> <li>Add <code>copp::make_channel&lt;T&gt;()</code> to create channel receiver and sender for easier usage.</li> </ol>"},{"location":"changelog/#220","title":"2.2.0","text":"<ol> <li>Merge boost.fcontext 1.81.0</li> <li>Add <code>LIBCOPP_MACRO_TLS_STACK_PROTECTOR</code> to work with <code>-fstack-protector</code></li> <li>Optimize <code>-pthread</code> flag detection.</li> <li>Support <code>-fno-rtti</code> now.</li> <li>Optimize timestamp of generated file to reduce regeneration.</li> </ol>"},{"location":"changelog/#214","title":"2.1.4","text":"<ol> <li>Fixes timer reset when initialization.(#46 )</li> <li>Update CI environment of GCC 4.8.</li> <li>Add more strict warnings.</li> <li>Optimize spin lock, add <code>valid()</code> for <code>task_promise</code>(C++ 20 coroutine).</li> <li>Fix consistent of variant detection.</li> </ol>"},{"location":"changelog/#212","title":"2.1.2","text":"<ul> <li>Update cmake-toolset</li> <li>Implement <code>unhandled_exception</code> when without exception.</li> </ul>"},{"location":"changelog/#211","title":"2.1.1","text":"<ul> <li>Add helper function to pick task id and private data from C++20 coroutine task</li> <li>Fix trivial test</li> <li>Fix <code>Valgrind_ROOT</code></li> <li>Fix compatibility of GCC SFINAE</li> <li>[CI] Add CodeQL job</li> <li>[CI] Add auto stale job</li> <li>[CI] Update linux image to ubuntu 22.04</li> </ul>"},{"location":"changelog/#210","title":"2.1.0","text":"<ol> <li>Allow custom <code>promise_error_transform</code> for C++20 coroutine.</li> </ol>"},{"location":"changelog/#202","title":"2.0.2","text":"<ol> <li>Add benchmark for <code>task_future</code></li> <li>Fix lifetime of <code>task_future</code></li> </ol>"},{"location":"changelog/#201","title":"2.0.1","text":"<ol> <li>Change <code>task_manager&lt;task_type, container_type&gt;</code> to <code>task_manager&lt;task_type&gt;</code></li> </ol>"},{"location":"changelog/#200","title":"2.0.0","text":"<ol> <li>Add ABI tag for all c++ codes <p>We will keep ABI compatitablity for all assemblly APIs and will change the suffix when ABI changed.</p> </li> <li><code>cotask::task</code> changes</li> <li>[x] Add <code>value_type</code> to task_macro ( <code>macro_coroutine</code> )</li> <li>[Previous] Redesign C++ 20 coroutine support.</li> <li>Using ctest to maintain test and samples</li> <li>Fix compatibility for C++20 attributes and macros</li> <li>[BREAK CHANGES] Rename <code>LIBCOPP_DISABLE_THIS_MT</code> to <code>LIBCOPP_LOCK_DISABLE_THIS_MT</code></li> </ol>"},{"location":"changelog/#150","title":"1.5.0","text":"<ol> <li>[BREAK CHANGES] We need gcc 4.8+, Clang 4.0+ or MSVC 1900(Visual Studio 2017)+</li> <li>Remove <code>COPP_MACRO_ENABLE_VARIADIC_TEMPLATE</code></li> <li>Remove <code>STD_DECLTYPE</code> , <code>COPP_MACRO_TYPEOF</code></li> <li>Remove <code>libcopp/utils/std/decltype.h</code></li> <li>Remove <code>libcopp/utils/config/compiler_features.h</code></li> <li>Remove <code>libcopp/utils/std/functional.h</code></li> <li>Remove <code>libcopp/utils/std/smart_ptr.h</code></li> </ol>"},{"location":"changelog/#141","title":"1.4.1","text":"<ol> <li>[OPTIMIZE] Allow to download submodule by external tool and do not depend <code>git</code>.</li> </ol>"},{"location":"changelog/#140","title":"1.4.0","text":"<ol> <li>[OPTIMIZE] Switch build system to to cmake-toolset</li> <li>[FIX] Fix output names of <code>find_package(&lt;PackageName&gt;)</code></li> <li>[OPTIMIZE] Support auto detection of ios/android toolchains</li> <li>[OPTIMIZE] Fix warnings when using cmake 3.20.0 or upper</li> <li>[OPTIMIZE] Optimize cmake config PATH for <code>&lt;PackageName&gt;_DIR</code></li> <li>[BREAK] Upgrade cmake requirement to 3.16.0+</li> <li>[CI] Move to github action</li> <li>[BOOST] Merge boost.context 1.76.0.</li> </ol>"},{"location":"changelog/#135","title":"1.3.5","text":"<ol> <li>[FIX] Fix stack alignment.</li> <li>[OPTIMIZE] Prefer to use python3 on cmake scripts.</li> </ol>"},{"location":"changelog/#134","title":"1.3.4","text":"<ol> <li>[FIX] Fix version tag.</li> </ol>"},{"location":"changelog/#133","title":"1.3.3","text":"<ol> <li>[BOOST] Merge boost.context 1.74.0(Support The 32-bit Solaris C language data model, called ILP32).</li> <li>[FIX] Fix mixed some headers with atframe_utils .</li> <li>[OPTIMIZE] Some optimizations for benchmark codes.</li> <li>[FIX] Fix multi-thread counter of unit test.</li> <li>[OPTIMIZE] Support cpack to generate rpm or deb package.</li> <li>[FIX] Fix c++20 coroutine flags when reimport CompilerOption.cmake.</li> </ol>"},{"location":"changelog/#132","title":"1.3.2","text":"<ol> <li>[FIX] #16 : document of  <code>LIBCOPP_DISABLE_ATOMIC_LOCK</code> and <code>LIBCOPP_DISABLE_THIS_MT</code> .</li> <li>[FIX] #18 : <code>'xx' is not a member of 'xxx {aka xxx}'</code> .</li> <li>[OPTIMIZE] <code>cotask::task</code> can capture all integer type of return value now.</li> <li>[FIX] Remove warning of c++20 coroutine options when project use both languages of cxx and not cxx</li> </ol>"},{"location":"changelog/#131-2020-07-06","title":"1.3.1 (2020-07-06)","text":"<ol> <li>Fix compiler version checker for C++20 coroutine</li> <li>Add cmake interface option and features for targets</li> <li>Update documents</li> </ol>"},{"location":"changelog/#130-2020-07-02","title":"1.3.0 (2020-07-02)","text":"<ol> <li>[OPTIMIZE] Using cmake export to generate module files</li> <li>[OPTIMIZE] Change default visibility of symbols to hidden, we support dll on windows now.</li> <li>[FIX] Rename <code>task::await`` into</code>task::await_task<code>, Some compile don't allow</code>await_task` as function name.</li> <li>[BOOST] Merge boost.context 1.73.0</li> <li>[FEATURE] Implement context of windows fiber and <code>SetUnhandledExceptionFilter</code> is available to catchunhandled exception in coroutine action</li> <li>[OPTIMIZE] Catch and rethrow unhandle exception after coroutine resumed when using C++11 or upper, most APIs are exception safe now.</li> <li>[OPTIMIZE] Remove TTASK_MACRO in cotask::task, task id now is always set <code>uint64_t</code> and use the id allocator with thread cache.</li> <li>[OPTIMIZE] Fix <code>Warning: client switching stacks?</code> in unit test when enable valgrind support.</li> <li>[FEATURE] Enable <code>-DLIBCOPP_FCONTEXT_USE_TSX=ON</code> for default.</li> </ol>"},{"location":"changelog/#break-changes-upgrade-guide-from-12x","title":"BREAK CHANGES &amp; UPGRADE GUIDE FROM 1.2.X","text":"<ul> <li>Rename <code>cotask::task::await</code> into <code>cotask::task::await_task</code></li> <li>Replace <code>cotask::task&lt;TCO_MACRO, TTASK_MACRO&gt;</code> with <code>cotask::task&lt;TCO_MACRO&gt;</code>, we don't allow to custom id allocator now.</li> <li>Replace <code>cotask::core::standard_int_id_allocator&lt;uint64_t&gt;</code> with <code>copp::util::uint64_id_allocator</code>, we don't allow to custom id allocator now.</li> <li>Require gcc 4.7+, MSVC 14+ (Visual Studio 2015)</li> <li>Require cmake 3.12.0 or upper</li> </ul>"},{"location":"changelog/#121-2019-10-04","title":"1.2.1 (2019-10-04)","text":"<ol> <li>[OPTIMIZE] Add options to disable TLS usage for this_task and this_coroutine to reduce cache miss on single thread situation.</li> <li>[OPTIMIZE] Implement jump_to(...) as static inline to reduce code cache miss.</li> <li>[OPTIMIZE] Implement coroutine_context_callback(...) as static local symbol to reduce code cache miss.</li> </ol>"},{"location":"changelog/#120-2019-08-20","title":"1.2.0 (2019-08-20)","text":"<ol> <li>[OPTIMIZE] Add more unit test.Increase coverage to 90%+.</li> <li>[OPTIMIZE] Rewrite toolchain detection scripts, support clang-cl now.</li> <li>[BOOST] merge boost.context 1.71.0.</li> <li>[FIX] Fix a coredump problem when task_ptr is reset when await_task other tasks.</li> <li>[OPTIMIZE] Optimize timer implement, task_manager support modify task timer now.</li> <li>[OPTIMIZE] A task can only be added to one task_manager now, and when finish task with task's API, task_manager will also be cleanup.</li> <li>[OPTIMIZE] Fix some warning when compiling with gcc 9+ and clang 8+.</li> <li>[OPTIMIZE] Use pthread  for TLS when both c++11 thead_local and pthread are available. It will reduce the minimal stack size.</li> <li>[OPTIMIZE] Fix and add some example codes and documents.</li> </ol>"},{"location":"changelog/#2018-12-07","title":"2018-12-07","text":"<ol> <li>[OPTIMIZE] add adaptor for vcpkg</li> <li>[OPTIMIZE] using GNUInstallDirs for all directories</li> <li>[BOOST] merge boost.context 1.67.0</li> <li>[OPTIMIZE] add libcopp-config.cmake and libcopp-config-version.cmake for cmake module</li> <li>[OPTIMIZE] add then and await_task API for easier usage</li> <li>[OPTIMIZE] add /Zc:__cplusplus for MSVC to make __cplusplus to the standard value.</li> <li>[OPTIMIZE] fix a guess to x86_64 environment</li> <li>[OPTIMIZE] add more API for statistics</li> <li>[FIX] fix the problem that calling compare_exchange_weak failed will lead the cotask to exit</li> <li>[OPTIMIZE] merge the latest unit test framework, now we will support more readable output when test failed.</li> <li>[CI] We use xenial to build in linux now.</li> </ol>"},{"location":"changelog/#2018-01-01","title":"2018-01-01","text":"<ol> <li>[BOOST] merge boost.context 1.66.0</li> <li>[OPTIMIZE] add support for Intel Transactional Synchronisation Extensions (TSX)</li> <li>[OPTIMIZE] fix a warning reported by clang-analyzer.</li> <li>[CI] update README.md and automatic documents.(published at https://libcopp.atframe.work)</li> <li>[FIX] make sure all the allocated stacks are always greater than the configure value after reloaded when using stack pool.</li> <li>[FIX] allow segmented stacks when using clang and llvm.</li> <li>[OPTIMIZE] using the new script to run clang-analyzer.</li> <li>[OPTIMIZE] optimize the doxygen output and fix some markdown synax not supported by doxygen.</li> </ol>"},{"location":"changelog/#2017-10-01","title":"2017-10-01","text":"<ol> <li>[OPTIMIZE] optimize cmake files for all target</li> <li>[OPTIMIZE] update samples and readme(fix sample for stack pool in README.md)</li> <li>[CI] add gcc 7</li> <li>[OPTIMIZE] using -std=c++17 for gcc/clang and /std:c++17 for MSVC 15(2015) and upper</li> </ol>"},{"location":"changelog/#2017-06-11","title":"2017-06-11","text":"<ol> <li>[OPTIMIZE] V2 framework and APIs completed, all reports in clang-analysis and cppcheck are fixed.</li> <li>[CI] benchmark and samples enabled in v2 branch</li> <li>[CI] add sample code in README.md into CI </li> </ol>"},{"location":"changelog/#2017-05-10","title":"2017-05-10","text":"<ol> <li>[BOOST] merge boost.context 1.64.0</li> <li>[OPTIMIZE] add stack pool manager and unit test</li> <li>[OPTIMIZE] reduce memory fragment when allocate coroutine task and task action</li> <li>[CI] benchmark and sample will always be run in Travis CI and Appveyor CI</li> </ol>"},{"location":"changelog/#2016-06-16","title":"2016-06-16","text":"<ol> <li>[BOOST] merge boost.context 1.61.0 and use the new jump progress(see https://owent.net/2016/1270.html for detail)</li> <li>[BOOST] enable valgrind support if valgrind/valgrind.h exists</li> <li>[CXX] use cmake to detect the function of compiler</li> <li>[OPTIMIZE] using pthread key when c++11 TLS not available</li> <li>[OPTIMIZE] remove coroutine_context_safe_base.coroutine_context_base is also thread safe now</li> <li>[OPTIMIZE] remove all global variables of cotask</li> <li>[OPTIMIZE] remove std/thread.h\u00ef\u00bc\u0152 add noexpect if available</li> <li>[CI] CI use build matrix to test more compiler</li> <li>[BUILD] use RelWithDebInfo for default</li> </ol>"},{"location":"changelog/#2016-02-27","title":"2016-02-27","text":"<ol> <li>v0.2.0, this version is used in our server for about one year.</li> </ol>"},{"location":"changelog/#2015-12-29","title":"2015-12-29","text":"<ol> <li>add support for valgrind</li> <li>add ci configure</li> <li>merge boost.context 1.60.0</li> <li>add -fPIC, fix spin lock</li> <li>some environment do not support TLS, make these environment can compile success</li> </ol>"},{"location":"changelog/#2014-07-25","title":"2014-07-25","text":"<p>v0.1.0</p>"},{"location":"channels/","title":"Channel/Receiver Pattern","text":"<p>Channels provide a powerful communication mechanism between coroutines in libcopp. They enable producer-consumer patterns and synchronization between both stackful and stackless (C++20) coroutines.</p>"},{"location":"channels/#overview","title":"Overview","text":"<p>The channel/receiver pattern in libcopp allows coroutines to send and receive values asynchronously:</p> <ul> <li>Sender: Produces values and sends them through a channel</li> <li>Receiver: Waits for and receives values from a channel</li> <li>Channel: The communication medium connecting senders and receivers</li> </ul> <p>Channels support:</p> <ul> <li>\u2705 Producer/Consumer patterns: One-to-one communication</li> <li>\u2705 Value transmission: Send any copyable/movable type</li> <li>\u2705 Void channels: Signal-only communication (no value)</li> <li>\u2705 Error handling: Custom error transformations</li> <li>\u2705 Both coroutine types: Stackful and stackless coroutines</li> </ul> <p>Note: Channels do NOT support true broadcasting/multicasting. While multiple coroutines can wait on the same receiver, they share the underlying context. When one receiver calls <code>reset_value()</code>, it affects all receivers sharing that context.</p>"},{"location":"channels/#stackful-coroutine-channels","title":"Stackful Coroutine Channels","text":"<p>Stackful channels work with <code>cotask::task</code> and <code>copp::coroutine_context</code>.</p>"},{"location":"channels/#api-reference","title":"API Reference","text":""},{"location":"channels/#creating-a-channel","title":"Creating a Channel","text":"<pre><code>#include &lt;libcopp/coroutine/stackful_channel.h&gt;\n\nauto [receiver, sender] = copp::make_stackful_channel&lt;int&gt;();\n</code></pre> <p>Returns: A pair of <code>stackful_channel_receiver&lt;T&gt;</code> and <code>stackful_channel_sender&lt;T&gt;</code></p>"},{"location":"channels/#stackful_channel_receivert","title":"<code>stackful_channel_receiver&lt;T&gt;</code>","text":"<p>The receiver waits for values from the channel.</p> <p>Methods:</p> <ul> <li><code>void reset_value()</code>: Reset the receiver to receive the next value</li> <li><code>bool is_ready() const</code>: Check if a value is ready</li> <li><code>bool is_pending() const</code>: Check if waiting for a value</li> </ul> <p>Usage with <code>cotask::task::await_value()</code>:</p> <pre><code>class consumer_action : public cotask::impl::task_action_impl {\n  copp::stackful_channel_receiver&lt;int&gt; receiver_;\n\n  int operator()(void*) override {\n    // Wait for and receive a value\n    int value = cotask::task&lt;&gt;::this_task()-&gt;await_value(receiver_);\n\n    // Reset for next value\n    receiver_.reset_value();\n\n    return 0;\n  }\n};\n</code></pre> <p>With error transform:</p> <pre><code>auto error_transform = [](copp::copp_error_code err) {\n  std::cerr &lt;&lt; \"Error: \" &lt;&lt; static_cast&lt;int&gt;(err) &lt;&lt; std::endl;\n  return -1;  // Default value on error\n};\n\nint value = cotask::task&lt;&gt;::this_task()-&gt;await_value(receiver_, error_transform);\n</code></pre> <p>Usage with <code>inject_await()</code> for low-level control:</p> <pre><code>int consumer_runner(void* data_ptr) {\n  auto* receiver = static_cast&lt;copp::stackful_channel_receiver&lt;int&gt;*&gt;(data_ptr);\n\n  // Get current coroutine context\n  auto* ctx = copp::this_coroutine::get&lt;copp::coroutine_context&gt;();\n\n  // Directly await on receiver\n  auto error_transform = [](copp::copp_error_code err) { return 0; };\n  int value = receiver-&gt;inject_await(ctx, error_transform);\n\n  receiver-&gt;reset_value();\n  return 0;\n}\n</code></pre>"},{"location":"channels/#stackful_channel_sendert","title":"<code>stackful_channel_sender&lt;T&gt;</code>","text":"<p>The sender sends values through the channel.</p> <p>Methods:</p> <ul> <li><code>void set_value(T&amp;&amp; value)</code>: Send a value through the channel</li> <li><code>void set_value(const T&amp; value)</code>: Send a value through the channel</li> </ul> <p>Usage:</p> <pre><code>copp::stackful_channel_sender&lt;int&gt; sender = /* ... */;\n\n// Send a value\nsender.set_value(42);\n\n// All waiting receivers will be resumed\n</code></pre>"},{"location":"channels/#complete-example","title":"Complete Example","text":"<pre><code>#include &lt;libcopp/coroutine/stackful_channel.h&gt;\n#include &lt;libcotask/task.h&gt;\n\nclass producer_action : public cotask::impl::task_action_impl {\n  copp::stackful_channel_sender&lt;int&gt; sender_;\n\n  int operator()(void*) override {\n    for (int i = 1; i &lt;= 5; ++i) {\n      sender_.set_value(i * 100);\n    }\n    return 0;\n  }\n};\n\nclass consumer_action : public cotask::impl::task_action_impl {\n  copp::stackful_channel_receiver&lt;int&gt; receiver_;\n\n  int operator()(void*) override {\n    for (int i = 1; i &lt;= 5; ++i) {\n      int value = cotask::task&lt;&gt;::this_task()-&gt;await_value(receiver_);\n      std::cout &lt;&lt; \"Received: \" &lt;&lt; value &lt;&lt; std::endl;\n      receiver_.reset_value();\n    }\n    return 0;\n  }\n};\n\nint main() {\n  auto [receiver, sender] = copp::make_stackful_channel&lt;int&gt;();\n\n  auto consumer = cotask::task&lt;&gt;::create(consumer_action(std::move(receiver)));\n  auto producer = cotask::task&lt;&gt;::create(producer_action(std::move(sender)));\n\n  consumer-&gt;start();\n  producer-&gt;start();\n\n  return 0;\n}\n</code></pre> <p>See: sample/sample_readme_13.cpp for full examples including: - Basic producer/consumer - Error handling with custom transforms - Direct usage with <code>copp::coroutine_context</code></p>"},{"location":"channels/#c20-coroutine-channels","title":"C++20 Coroutine Channels","text":"<p>Stackless channels work with C++20 coroutines (<code>copp::callable_future</code>, <code>copp::generator_future</code>).</p>"},{"location":"channels/#api-reference_1","title":"API Reference","text":""},{"location":"channels/#creating-a-channel_1","title":"Creating a Channel","text":"<pre><code>#include &lt;libcopp/coroutine/generator_promise.h&gt;\n\nauto [receiver, sender] = copp::make_channel&lt;int&gt;();\n</code></pre> <p>Returns: A pair of <code>generator_channel_receiver&lt;T&gt;</code> and <code>generator_channel_sender&lt;T&gt;</code></p> <p>Types: - <code>generator_channel_receiver&lt;T, ErrorTransform&gt;</code>: Alias for <code>generator_channel_future&lt;T, ErrorTransform&gt;</code> - <code>generator_channel_sender&lt;T, ErrorTransform&gt;</code>: A smart pointer (<code>context_pointer_type</code>) to the channel context</p>"},{"location":"channels/#generator_channel_receivert-errortransform","title":"<code>generator_channel_receiver&lt;T, ErrorTransform&gt;</code>","text":"<p>The receiver is an awaitable that suspends the coroutine until a value is available.</p> <p>Template Parameters: - <code>T</code>: Value type (use <code>void</code> for signal-only channels) - <code>ErrorTransform</code>: Error transform functor (default: <code>promise_error_transform&lt;T&gt;</code>)</p> <p>Methods: - <code>void reset_value()</code>: Reset the receiver to receive the next value - <code>bool is_ready() const</code>: Check if a value is ready - <code>bool is_pending() const</code>: Check if waiting for a value - <code>promise_status get_status() const</code>: Get current status</p> <p>Usage with <code>co_await</code>:</p> <pre><code>copp::callable_future&lt;int&gt; consumer(copp::generator_channel_receiver&lt;int&gt; receiver) {\n  // Suspend until value is available\n  int value = co_await receiver;\n\n  std::cout &lt;&lt; \"Received: \" &lt;&lt; value &lt;&lt; std::endl;\n\n  // Reset for next value\n  receiver.reset_value();\n\n  co_return value;\n}\n</code></pre> <p>For <code>void</code> channels:</p> <pre><code>copp::callable_future&lt;void&gt; consumer(copp::generator_channel_receiver&lt;void&gt; receiver) {\n  // Wait for signal\n  co_await receiver;\n  std::cout &lt;&lt; \"Signal received!\" &lt;&lt; std::endl;\n\n  receiver.reset_value();\n  co_return;\n}\n</code></pre>"},{"location":"channels/#generator_channel_sendert-errortransform","title":"<code>generator_channel_sender&lt;T, ErrorTransform&gt;</code>","text":"<p>The sender is a smart pointer to the channel context.</p> <p>Methods: - <code>void set_value(T&amp;&amp; value)</code>: Send a value (for non-void channels) - <code>void set_value(const T&amp; value)</code>: Send a value (for non-void channels) - <code>void set_value()</code>: Send a signal (for void channels)</p> <p>Usage:</p> <pre><code>copp::generator_channel_sender&lt;int&gt; sender = /* ... */;\n\n// Send a value\nsender-&gt;set_value(42);  // Note: use -&gt; operator\n\n// All waiting coroutines will be resumed\n</code></pre>"},{"location":"channels/#custom-error-transform","title":"Custom Error Transform","text":"<p>Define custom error handling for channel operations:</p> <pre><code>struct custom_error_transform {\n  int operator()(copp::promise_status status) const {\n    if (status == copp::promise_status::kKilled) {\n      return -999;\n    } else if (status == copp::promise_status::kTimeout) {\n      return -888;\n    }\n    return -1;\n  }\n};\n\nauto [receiver, sender] = copp::make_channel&lt;int, custom_error_transform&gt;();\n\nauto consumer_future = consumer(std::move(receiver));\n\n// Kill the consumer to trigger error transform\nconsumer_future.kill(copp::promise_status::kKilled, true);\n\n// consumer_future.get_internal_promise().data() == -999\n</code></pre>"},{"location":"channels/#complete-example_1","title":"Complete Example","text":"<pre><code>#include &lt;libcopp/coroutine/callable_promise.h&gt;\n#include &lt;libcopp/coroutine/generator_promise.h&gt;\n\ncopp::callable_future&lt;void&gt; producer(copp::generator_channel_sender&lt;int&gt; sender, int count) {\n  for (int i = 1; i &lt;= count; ++i) {\n    sender-&gt;set_value(i * 100);\n    co_await copp::callable_future&lt;void&gt;::yield();\n  }\n  co_return;\n}\n\ncopp::callable_future&lt;int&gt; consumer(copp::generator_channel_receiver&lt;int&gt; receiver, int count) {\n  int sum = 0;\n  for (int i = 1; i &lt;= count; ++i) {\n    int value = co_await receiver;\n    sum += value;\n    receiver.reset_value();\n  }\n  co_return sum;\n}\n\nint main() {\n  auto [receiver, sender] = copp::make_channel&lt;int&gt;();\n\n  auto consumer_future = consumer(std::move(receiver), 5);\n  auto producer_future = producer(sender, 5);\n\n  int total = consumer_future.get_internal_promise().data();\n  // total == 1500 (100 + 200 + 300 + 400 + 500)\n\n  return 0;\n}\n</code></pre> <p>See: sample/sample_readme_14.cpp for full examples including: - Basic channel usage - Producer/consumer pattern - Error handling with custom transforms - Void channels for signaling - Comparison of generator vtable types</p>"},{"location":"channels/#usage-patterns","title":"Usage Patterns","text":""},{"location":"channels/#producerconsumer","title":"Producer/Consumer","text":"<p>One producer sends values, one consumer receives them.</p> <p>Best for: Pipeline processing, task queues</p> <pre><code>// Stackful\nauto [receiver, sender] = copp::make_stackful_channel&lt;int&gt;();\n\n// C++20\nauto [receiver, sender] = copp::make_channel&lt;int&gt;();\n</code></pre>"},{"location":"channels/#signal-only-communication","title":"Signal-only Communication","text":"<p>Use <code>void</code> channels when you only need to signal events without data.</p> <p>Best for: Synchronization, wake-up notifications</p> <pre><code>auto [receiver, sender] = copp::make_channel&lt;void&gt;();\n\n// Sender\nsender-&gt;set_value();  // Send signal\n\n// Receiver\nco_await receiver;  // Wait for signal\n</code></pre>"},{"location":"channels/#generator-vtable-types-c20-only","title":"Generator VTable Types (C++20 Only)","text":"<p>libcopp provides three generator vtable types for different performance/flexibility tradeoffs:</p>"},{"location":"channels/#generator_vtable_typekdefault","title":"<code>generator_vtable_type::kDefault</code>","text":"<p>Type: <code>copp::generator_future&lt;T&gt;</code></p> <ul> <li>Uses <code>std::function</code> for callbacks</li> <li>Most flexible - can capture complex state</li> <li>Higher overhead due to type erasure</li> <li>Best for: Complex scenarios with stateful callbacks</li> </ul> <pre><code>copp::generator_future&lt;int&gt; future{\n  [captured_state](copp::generator_future&lt;int&gt;::context_pointer_type ctx) {\n    // Can capture complex state\n  },\n  [](const copp::generator_future&lt;int&gt;::context_type&amp; ctx) {\n    // Resume callback\n  }\n};\n</code></pre>"},{"location":"channels/#generator_vtable_typeklightweight","title":"<code>generator_vtable_type::kLightWeight</code>","text":"<p>Type: <code>copp::generator_lightweight_future&lt;T&gt;</code></p> <ul> <li>Uses function pointers instead of <code>std::function</code></li> <li>Lower overhead, faster performance</li> <li>Cannot capture state in callbacks</li> <li>Best for: Performance-critical code with simple callbacks</li> </ul> <pre><code>void on_suspend(copp::generator_lightweight_future&lt;int&gt;::context_pointer_type ctx) {\n  // Function pointer - no captures\n}\n\ncopp::generator_lightweight_future&lt;int&gt; future{on_suspend};\n</code></pre>"},{"location":"channels/#generator_vtable_typeknone","title":"<code>generator_vtable_type::kNone</code>","text":"<p>Type: <code>copp::generator_channel_future&lt;T&gt;</code> (used by <code>make_channel()</code>)</p> <ul> <li>No callbacks - designed for channel pattern</li> <li>Minimal overhead, most efficient</li> <li>Best for: Channel-based communication</li> </ul> <pre><code>auto [receiver, sender] = copp::make_channel&lt;int&gt;();\n// receiver is generator_channel_future&lt;int&gt;\n</code></pre>"},{"location":"channels/#recommendation","title":"Recommendation","text":"Use Case Recommended Type Channel communication <code>make_channel()</code> (kNone) Simple futures <code>generator_lightweight_future</code> (kLightWeight) Complex futures with state <code>generator_future</code> (kDefault)"},{"location":"channels/#performance-considerations","title":"Performance Considerations","text":""},{"location":"channels/#when-to-use-stackful-vs-stackless","title":"When to Use Stackful vs Stackless","text":"Feature Stackful Channels Stackless Channels (C++20) Stack usage Allocates stack per coroutine No stack allocation Compatibility Works on all C++11+ compilers Requires C++20 support Integration Works with existing callback APIs Better with async/await code Performance Slightly higher overhead Lower overhead Debugging Easier to debug stack traces Harder to debug state machines <p>Recommendation: - Use stackful if you need C++11/14/17 compatibility or work with callback-heavy code - Use stackless if you have C++20 and want modern async/await syntax</p>"},{"location":"channels/#channel-best-practices","title":"Channel Best Practices","text":"<ol> <li> <p>Always <code>reset_value()</code> after receiving <pre><code>int value = co_await receiver;\nreceiver.reset_value();  // Required for next receive\n</code></pre></p> </li> <li> <p>Avoid blocking senders</p> </li> <li>Channels don't buffer values</li> <li>Sender resumes all waiting receivers immediately</li> <li> <p>If no receivers are waiting, the value is stored until next <code>co_await</code></p> </li> <li> <p>Error handling</p> </li> <li>Always provide error transforms for production code</li> <li>Handle <code>promise_status::kKilled</code> and <code>kTimeout</code> cases</li> <li>Default error transform returns default-constructed value</li> </ol>"},{"location":"channels/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"channels/#forgetting-to-reset","title":"Forgetting to Reset","text":"<pre><code>// \u274c Wrong\nint v1 = co_await receiver;\nint v2 = co_await receiver;  // Returns same value!\n\n// \u2705 Correct\nint v1 = co_await receiver;\nreceiver.reset_value();\nint v2 = co_await receiver;\n</code></pre>"},{"location":"channels/#sender-access-pattern-difference","title":"Sender Access Pattern Difference","text":"<pre><code>// Stackful\ncopp::stackful_channel_sender&lt;int&gt; sender;\nsender.set_value(42);  // Direct method call\n\n// Stackless (C++20)\ncopp::generator_channel_sender&lt;int&gt; sender;  // This is a smart pointer\nsender-&gt;set_value(42);  // Use -&gt; operator\n</code></pre>"},{"location":"channels/#not-handling-errors","title":"Not Handling Errors","text":"<pre><code>// \u274c Without error handling\nint value = co_await receiver;  // May return default value on error\n\n// \u2705 With error handling\nauto [receiver, sender] = copp::make_channel&lt;int, custom_error_transform&gt;();\n</code></pre>"},{"location":"channels/#see-also","title":"See Also","text":"<ul> <li>Examples - Full working examples</li> <li>sample_readme_13.cpp - Stackful channel examples</li> <li>sample_readme_14.cpp - C++20 channel examples</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"doxygen-index/","title":"Doxygen index","text":"<p>Welcome to API document of libcopp.</p> <p>Please browse sample directory in Files or just search for <code>task</code> \u3001 <code>task_manager</code> \u3001 <code>coroutine_context</code> \u3001 <code>coroutine_context_container</code> \u3001 <code>coroutine_context_fiber</code> \u3001 <code>coroutine_context_container_fiber</code> \u3001 <code>stack_pool</code> \u3001<code>stack_traits</code> or any other keywords.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>This section summarizes the stress test reports captured in <code>docs/reports</code> and provides the raw logs for reference.</p>"},{"location":"benchmarks/#how-to-run","title":"How to run","text":""},{"location":"benchmarks/#windows","title":"Windows","text":"<pre><code>@echo off\n\n\"%1/sample/Release/sample_benchmark_coroutine_mem_pool.exe\" 10000 1000 200 &gt;&gt; \"%2\"\n\"%1/sample/Release/sample_benchmark_coroutine_mem_pool.exe\" 1000 1000 2048 &gt;&gt; \"%2\"\necho\\  &gt;&gt; \"%2\"\n\n\"%1/sample/Release/sample_benchmark_coroutine.exe\" 10000 1000 200 &gt;&gt; \"%2\"\n\"%1/sample/Release/sample_benchmark_coroutine.exe\" 1000 1000 2048 &gt;&gt; \"%2\"\necho\\  &gt;&gt; \"%2\"\n\n\"%1/sample/Release/sample_benchmark_coroutine_malloc.exe\" 10000 1000 200 &gt;&gt; \"%2\"\n\"%1/sample/Release/sample_benchmark_coroutine_malloc.exe\" 1000 1000 2048 &gt;&gt; \"%2\"\necho\\  &gt;&gt; \"%2\"\n\n\"%1/sample/Release/sample_benchmark_task_mem_pool.exe\" 10000 1000 200 &gt;&gt; \"%2\"\n\"%1/sample/Release/sample_benchmark_task_mem_pool.exe\" 1000 1000 2048 &gt;&gt; \"%2\"\necho\\  &gt;&gt; \"%2\"\n\n\"%1/sample/Release/sample_benchmark_task.exe\" 10000 1000 200 &gt;&gt; \"%2\"\n\"%1/sample/Release/sample_benchmark_task.exe\" 1000 1000 2048 &gt;&gt; \"%2\"\necho\\  &gt;&gt; \"%2\"\n\n\"%1/sample/Release/sample_benchmark_task_malloc.exe\" 10000 1000 200 &gt;&gt; \"%2\"\n\"%1/sample/Release/sample_benchmark_task_malloc.exe\" 1000 1000 2048 &gt;&gt; \"%2\"\necho\\  &gt;&gt; \"%2\"\n</code></pre>"},{"location":"benchmarks/#linux","title":"Linux","text":"<pre><code>#!/bin/sh\n\nif [ $# -lt 2 ]; then\n    echo \"usage: $0 &lt;build dir&gt; &lt;report file&gt;\";\n    exit -1;\nfi\n\n\"$1\"/sample/sample_benchmark_coroutine_mem_pool 10000 1000 200 &gt;&gt; \"$2\";\n\"$1\"/sample/sample_benchmark_coroutine_mem_pool 1000 1000 2048 &gt;&gt; \"$2\";\necho \"\" &gt;&gt; \"$2\";\n\n\"$1\"/sample/sample_benchmark_coroutine 10000 1000 200 &gt;&gt; \"$2\";\n\"$1\"/sample/sample_benchmark_coroutine 1000 1000 2048 &gt;&gt; \"$2\";\necho \"\" &gt;&gt; \"$2\";\n\n\"$1\"/sample/sample_benchmark_coroutine_malloc 10000 1000 200 &gt;&gt; \"$2\";\n\"$1\"/sample/sample_benchmark_coroutine_malloc 1000 1000 2048 &gt;&gt; \"$2\";\necho \"\" &gt;&gt; \"$2\";\n\n\"$1\"/sample/sample_benchmark_task_mem_pool 10000 1000 200 &gt;&gt; \"$2\";\n\"$1\"/sample/sample_benchmark_task_mem_pool 1000 1000 2048 &gt;&gt; \"$2\";\necho \"\" &gt;&gt; \"$2\";\n\n\"$1\"/sample/sample_benchmark_task 10000 1000 200 &gt;&gt; \"$2\";\n\"$1\"/sample/sample_benchmark_task 1000 1000 2048 &gt;&gt; \"$2\";\necho \"\" &gt;&gt; \"$2\";\n\n\"$1\"/sample/sample_benchmark_task_malloc 10000 1000 200 &gt;&gt; \"$2\";\n\"$1\"/sample/sample_benchmark_task_malloc 1000 1000 2048 &gt;&gt; \"$2\";\necho \"\" &gt;&gt; \"$2\";\n</code></pre>"},{"location":"benchmarks/#summary","title":"Summary","text":"<ul> <li>Each report measures allocate/create/switch/remove cycles for coroutine contexts and tasks with different stack allocators.</li> <li>Use the raw logs below for precise numbers and environment details.</li> </ul>"},{"location":"benchmarks/linux/","title":"Linux Benchmarks","text":""},{"location":"benchmarks/linux/#summary","title":"Summary","text":"<ul> <li>Environment: Linux 3.14.3-200.fc20.x86_64 (gcc 4.8.2)</li> <li>CPU: AMD Phenom(tm) II X4 830 Processor (800MHz- 2800MHz)</li> <li>Memory: 8GB DDR3-1333</li> <li>Build type: RelWithDebInfo</li> <li>Thread number: 1, stack memory cost 2.0GB</li> </ul>"},{"location":"benchmarks/linux/#raw-report","title":"Raw report","text":"Linux raw report <pre><code>=======================================================================================\nEnv: Linux version 3.14.3-200.fc20.x86_64 (mockbuild@bkernel02) (gcc version 4.8.2 20131212 (Red Hat 4.8.2-7) (GCC) ) #1 SMP Tue May 6 19:00:18 UTC 2014\nSystem: Linux\nCPU: AMD Phenom(tm) II X4 830 Processor (800MHz- 2800MHz)\nMemory: 8GB DDR3-1333\nCMake Build Type: RelWithDebInfo\nRun Env =&gt; thread number: 1, stack memory cost 2.0GB\nCompile Options:-O2 -g -DNDEBUG -ggdb -std=gnu++11 -Wall -Werror -rdynamic -Wno-unused-local-typedefs -fsplit-stack\n\n###################### context coroutine (stack using memory pool) ###################\n########## Cmd: sample/sample_stress_test_coroutine_mem_pool 10000 1000 200\nallocate 10000 coroutine, cost time: 0 s, clock time: 4 ms, avg: 400 ns\ncreate 10000 coroutine, cost time: 0 s, clock time: 50 ms, avg: 5000 ns\nswitch 10000 coroutine contest 10000000 times, cost time: 4 s, clock time: 3706 ms, avg: 370 ns\nremove 10000 coroutine, cost time: 0 s, clock time: 9 ms, avg: 900 ns\n########## Cmd: sample/sample_stress_test_coroutines_mem_pool 1000 1000 2048\nallocate 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns\ncreate 1000 coroutine, cost time: 0 s, clock time: 5 ms, avg: 5000 ns\nswitch 1000 coroutine contest 1000000 times, cost time: 0 s, clock time: 282 ms, avg: 282 ns\nremove 1000 coroutine, cost time: 0 s, clock time: 2 ms, avg: 2000 ns\n\n###################### context coroutine (stack using default allocator[mmap]) ###################\n########## Cmd: sample/sample_stress_test_coroutine 10000 1000 200\nallocate 10000 coroutine, cost time: 0 s, clock time: 2 ms, avg: 200 ns\ncreate 10000 coroutine, cost time: 0 s, clock time: 74 ms, avg: 7400 ns\nswitch 10000 coroutine contest 10000000 times, cost time: 4 s, clock time: 3407 ms, avg: 340 ns\nremove 10000 coroutine, cost time: 0 s, clock time: 30 ms, avg: 3000 ns\n########## Cmd: sample/sample_stress_test_coroutine 1000 1000 2048\nallocate 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns\ncreate 1000 coroutine, cost time: 0 s, clock time: 8 ms, avg: 8000 ns\nswitch 1000 coroutine contest 1000000 times, cost time: 0 s, clock time: 223 ms, avg: 223 ns\nremove 1000 coroutine, cost time: 0 s, clock time: 4 ms, avg: 4000 ns\n\n###################### context coroutine (stack using malloc/free [ptmalloc]) ###################\n########## Cmd: sample/sample_stress_test_coroutine_malloc 10000 1000 200\nallocate 10000 coroutine, cost time: 0 s, clock time: 6 ms, avg: 600 ns\ncreate 10000 coroutine, cost time: 0 s, clock time: 81 ms, avg: 8100 ns\nswitch 10000 coroutine contest 10000000 times, cost time: 4 s, clock time: 3809 ms, avg: 380 ns\nremove 10000 coroutine, cost time: 0 s, clock time: 26 ms, avg: 2600 ns\n########## Cmd: sample/sample_stress_test_coroutine_malloc 1000 1000 2048\nallocate 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns\ncreate 1000 coroutine, cost time: 0 s, clock time: 8 ms, avg: 8000 ns\nswitch 1000 coroutine contest 1000000 times, cost time: 0 s, clock time: 248 ms, avg: 248 ns\nremove 1000 coroutine, cost time: 0 s, clock time: 4 ms, avg: 4000 ns\n\n###################### task (stack using memory pool) ###################\n########## Cmd: sample/sample_stress_test_task_mem_pool 10000 1000 200\ncreate 10000 task, cost time: 0 s, clock time: 46 ms, avg: 4600 ns\nswitch 10000 tasks 10000000 times, cost time: 5 s, clock time: 4914 ms, avg: 491 ns\nremove 10000 tasks, cost time: 0 s, clock time: 1 ms, avg: 100 ns\n########## Cmd: sample/sample_stress_test_task_mem_pool 1000 1000 2048\ncreate 1000 task, cost time: 0 s, clock time: 6 ms, avg: 6000 ns\nswitch 1000 tasks 1000000 times, cost time: 1 s, clock time: 336 ms, avg: 336 ns\nremove 1000 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns\n\n###################### task (stack using default allocator[mmap]) ###################\n########## Cmd: sample/sample_stress_test_task 10000 1000 200\ncreate 10000 task, cost time: 0 s, clock time: 78 ms, avg: 7800 ns\nswitch 10000 tasks 10000000 times, cost time: 5 s, clock time: 5134 ms, avg: 513 ns\nremove 10000 tasks, cost time: 0 s, clock time: 34 ms, avg: 3400 ns\n########## Cmd: sample/sample_stress_test_task 1000 1000 2048\ncreate 1000 task, cost time: 0 s, clock time: 8 ms, avg: 8000 ns\nswitch 1000 tasks 1000000 times, cost time: 0 s, clock time: 330 ms, avg: 330 ns\nremove 1000 tasks, cost time: 0 s, clock time: 4 ms, avg: 4000 ns\n\n###################### task (stack using malloc/free [ptmalloc]) ###################\n########## Cmd: sample/sample_stress_test_task_malloc 10000 1000 200\ncreate 10000 task, cost time: 0 s, clock time: 73 ms, avg: 7300 ns\nswitch 10000 tasks 10000000 times, cost time: 5 s, clock time: 4803 ms, avg: 480 ns\nremove 10000 tasks, cost time: 0 s, clock time: 31 ms, avg: 3100 ns\n########## Cmd: sample/sample_stress_test_task_malloc 1000 1000 2048\ncreate 1000 task, cost time: 0 s, clock time: 9 ms, avg: 9000 ns\nswitch 1000 tasks 1000000 times, cost time: 0 s, clock time: 335 ms, avg: 335 ns\nremove 1000 tasks, cost time: 1 s, clock time: 4 ms, avg: 4000 ns\n</code></pre>"},{"location":"benchmarks/windows/","title":"Windows Benchmarks","text":""},{"location":"benchmarks/windows/#summary","title":"Summary","text":"<ul> <li>Environment: Windows 7, Visual Studio 2013 (VC 18)</li> <li>CPU: AMD Phenom(tm) II X4 830 Processor (800MHz- 2800MHz)</li> <li>Memory: 8GB DDR3-1333</li> <li>Build type: Release</li> <li>Thread number: 1, stack memory cost 2.0GB</li> </ul>"},{"location":"benchmarks/windows/#raw-report","title":"Raw report","text":"Windows raw report <pre><code>=======================================================================================\nEnv: Windows 7, Visual Studio 2013 (VC 18)\nSystem: Windows 7\nCPU: AMD Phenom(tm) II X4 830 Processor (800MHz- 2800MHz)\nMemory: 8GB DDR3-1333\nCMake Build Type: Release\nRun Env =&gt; thread number: 1, stack memory cost 2.0GB\nCompile Options: /GS /TP /W3 /Zi /Gm- /O2 /Ob2 /GL /EHsc /nologo /D \"NDEBUG\"\n\n###################### context coroutine (stack using memory pool) ################### \n########## Cmd: sample/Release/sample_stress_test_coroutines_mem_pool 10000 1000 200 \nallocate 10000 coroutine, cost time: 0 s, clock time: 11 ms, avg: 1100 ns\ncreate 10000 coroutine, cost time: 0 s, clock time: 296 ms, avg: 29600 ns\nswitch 10000 coroutine contest 10000000 times, cost time: 6 s, clock time: 6359 ms, avg: 635 ns\nremove 10000 coroutine, cost time: 1 s, clock time: 209 ms, avg: 20900 ns\n########## Cmd: sample/Release/sample_stress_test_coroutines_mem_pool 1000 1000 2048 \nallocate 1000 coroutine, cost time: 0 s, clock time: 2 ms, avg: 2000 ns\ncreate 1000 coroutine, cost time: 0 s, clock time: 37 ms, avg: 37000 ns\nswitch 1000 coroutine contest 1000000 times, cost time: 0 s, clock time: 308 ms, avg: 308 ns\nremove 1000 coroutine, cost time: 0 s, clock time: 7 ms, avg: 7000 ns\n\n###################### context coroutine (stack using default allocator[VirtualAlloc]) ################### \n########## Cmd: sample/Release/sample_stress_test_coroutine 10000 1000 200 \nallocate 10000 coroutine, cost time: 0 s, clock time: 11 ms, avg: 1100 ns\ncreate 10000 coroutine, cost time: 0 s, clock time: 139 ms, avg: 13900 ns\nswitch 10000 coroutine contest 10000000 times, cost time: 6 s, clock time: 6251 ms, avg: 625 ns\nremove 10000 coroutine, cost time: 0 s, clock time: 21 ms, avg: 2100 ns\n########## Cmd: sample/Release/sample_stress_test_coroutine 1000 1000 2048 \nallocate 1000 coroutine, cost time: 0 s, clock time: 1 ms, avg: 1000 ns\ncreate 1000 coroutine, cost time: 0 s, clock time: 15 ms, avg: 15000 ns\nswitch 1000 coroutine contest 1000000 times, cost time: 1 s, clock time: 275 ms, avg: 275 ns\nremove 1000 coroutine, cost time: 0 s, clock time: 4 ms, avg: 4000 ns\n\n###################### context coroutine (stack using malloc/free) ################### \n########## Cmd: sample/Release/sample_stress_test_coroutine_malloc 10000 1000 200 \nallocate 10000 coroutine, cost time: 0 s, clock time: 12 ms, avg: 1200 ns\ncreate 10000 coroutine, cost time: 0 s, clock time: 228 ms, avg: 22800 ns\nswitch 10000 coroutine contest 10000000 times, cost time: 6 s, clock time: 6282 ms, avg: 628 ns\nremove 10000 coroutine, cost time: 0 s, clock time: 16 ms, avg: 1600 ns\n########## Cmd: sample/Release/sample_stress_test_coroutine_malloc 1000 1000 2048 \nallocate 1000 coroutine, cost time: 0 s, clock time: 1 ms, avg: 1000 ns\ncreate 1000 coroutine, cost time: 0 s, clock time: 22 ms, avg: 22000 ns\nswitch 1000 coroutine contest 1000000 times, cost time: 1 s, clock time: 463 ms, avg: 463 ns\nremove 1000 coroutine, cost time: 0 s, clock time: 4 ms, avg: 4000 ns\n\n###################### task (stack using memory pool) ################### \n########## Cmd: sample/Release/sample_stress_test_task_mem_pool 10000 1000 200 \ncreate 10000 task, cost time: 0 s, clock time: 249 ms, avg: 24900 ns\nswitch 10000 tasks 10000000 times, cost time: 9 s, clock time: 8873 ms, avg: 887 ns\nremove 10000 tasks, cost time: 0 s, clock time: 4 ms, avg: 400 ns\n########## Cmd: sample/Release/sample_stress_test_task_mem_pool 1000 1000 2048 \ncreate 1000 task, cost time: 0 s, clock time: 27 ms, avg: 27000 ns\nswitch 1000 tasks 1000000 times, cost time: 1 s, clock time: 564 ms, avg: 564 ns\nremove 1000 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns\n\n###################### task (stack using default allocator[VirtualAlloc]) ################### \n########## Cmd: sample/Release/sample_stress_test_task 10000 1000 200 \ncreate 10000 task, cost time: 0 s, clock time: 167 ms, avg: 16700 ns\nswitch 10000 tasks 10000000 times, cost time: 9 s, clock time: 9440 ms, avg: 944 ns\nremove 10000 tasks, cost time: 0 s, clock time: 29 ms, avg: 2900 ns\n########## Cmd: sample/Release/sample_stress_test_task 1000 1000 2048 \ncreate 1000 task, cost time: 0 s, clock time: 18 ms, avg: 18000 ns\nswitch 1000 tasks 1000000 times, cost time: 1 s, clock time: 515 ms, avg: 515 ns\nremove 1000 tasks, cost time: 0 s, clock time: 6 ms, avg: 6000 ns\n\n###################### task (stack using malloc/free) ################### \n########## Cmd: sample/Release/sample_stress_test_task_malloc 10000 1000 200 \ncreate 10000 task, cost time: 0 s, clock time: 335 ms, avg: 33500 ns\nswitch 10000 tasks 10000000 times, cost time: 10 s, clock time: 10102 ms, avg: 1010 ns\nremove 10000 tasks, cost time: 0 s, clock time: 75 ms, avg: 7500 ns\n########## Cmd: sample/Release/sample_stress_test_task_malloc 1000 1000 2048 \ncreate 1000 task, cost time: 0 s, clock time: 44 ms, avg: 44000 ns\nswitch 1000 tasks 1000000 times, cost time: 1 s, clock time: 543 ms, avg: 543 ns\nremove 1000 tasks, cost time: 0 s, clock time: 9 ms, avg: 9000 ns\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#coroutine-context-example","title":"Coroutine context example","text":"<p>This is a simple example of using basic coroutine context below:</p> <pre><code>#include &lt;inttypes.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n\n// include context header file\n#include &lt;libcopp/coroutine/coroutine_context_container.h&gt;\n\n// define a coroutine runner\nint my_runner(void *) {\n  copp::coroutine_context *addr = copp::this_coroutine::get_coroutine();\n\n  std::cout &lt;&lt; \"cortoutine \" &lt;&lt; addr &lt;&lt; \" is running.\" &lt;&lt; std::endl;\n\n  addr-&gt;yield();\n\n  std::cout &lt;&lt; \"cortoutine \" &lt;&lt; addr &lt;&lt; \" is resumed.\" &lt;&lt; std::endl;\n\n  return 1;\n}\n\nint main() {\n  typedef copp::coroutine_context_default coroutine_type;\n\n  // create a coroutine\n  copp::coroutine_context_default::ptr_t co_obj = coroutine_type::create(my_runner);\n  std::cout &lt;&lt; \"cortoutine \" &lt;&lt; co_obj &lt;&lt; \" is created.\" &lt;&lt; std::endl;\n\n  // start a coroutine\n  co_obj-&gt;start();\n\n  // yield from my_runner\n  std::cout &lt;&lt; \"cortoutine \" &lt;&lt; co_obj &lt;&lt; \" is yield.\" &lt;&lt; std::endl;\n  co_obj-&gt;resume();\n\n  std::cout &lt;&lt; \"cortoutine \" &lt;&lt; co_obj &lt;&lt; \" exit and return \" &lt;&lt; co_obj-&gt;get_ret_code() &lt;&lt; \".\" &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre> <p>Also, you can use <code>copp::coroutine_context_container&lt;ALLOCATOR&gt;</code> instead of <code>copp::coroutine_context_default</code> to use a different stack allocator.</p>"},{"location":"examples/#coroutine-task-example","title":"Coroutine task example","text":"<p>This is a simple example of using coroutine task with lambda expression:</p> <pre><code>#include &lt;iostream&gt;\n\n// include task header file\n#include &lt;libcotask/task.h&gt;\n\ntypedef cotask::task&lt;&gt; my_task_t;\n\nint main() {\n  // create a task using factory function [with lambda expression]\n  my_task_t::ptr_t task = my_task_t::create([]() {\n    std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" started\" &lt;&lt; std::endl;\n    cotask::this_task::get_task()-&gt;yield();\n    std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" resumed\" &lt;&lt; std::endl;\n    return 0;\n  });\n\n  std::cout &lt;&lt; \"task \" &lt;&lt; task-&gt;get_id() &lt;&lt; \" created\" &lt;&lt; std::endl;\n  // start a task\n  task-&gt;start();\n\n  std::cout &lt;&lt; \"task \" &lt;&lt; task-&gt;get_id() &lt;&lt; \" yield\" &lt;&lt; std::endl;\n  task-&gt;resume();\n  std::cout &lt;&lt; \"task \" &lt;&lt; task-&gt;get_id() &lt;&lt; \" stoped, ready to be destroyed.\" &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre> <p>Also, you can your stack allocator or id allocator by setting different parameters in template class cotask::task."},{"location":"examples/#using-coroutine-task-manager","title":"Using coroutine task manager","text":"<p>This is a simple example of using task manager:</p> <pre><code>#include &lt;inttypes.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n\n// include context header file\n#include &lt;libcotask/task.h&gt;\n#include &lt;libcotask/task_manager.h&gt;\n\n// create a task manager\ntypedef cotask::task&lt;&gt; my_task_t;\ntypedef my_task_t::ptr_t task_ptr_type;\ntypedef cotask::task_manager&lt;my_task_t&gt; mgr_t;\nmgr_t::ptr_t task_mgr = mgr_t::create();\n\n// If you task manager to manage timeout, it's important to call tick interval\n\nvoid tick() {\n  // the first parameter is second, and the second is nanosecond\n  task_mgr-&gt;tick(time(nullptr), 0);\n}\n\nint main() {\n  // create two coroutine task\n  task_ptr_type co_task = my_task_t::create([]() {\n    std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" started\" &lt;&lt; std::endl;\n    cotask::this_task::get_task()-&gt;yield();\n    std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" resumed\" &lt;&lt; std::endl;\n    return 0;\n  });\n  task_ptr_type co_another_task = my_task_t::create([]() {\n    std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" started\" &lt;&lt; std::endl;\n    cotask::this_task::get_task()-&gt;yield();\n    std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" resumed\" &lt;&lt; std::endl;\n    return 0;\n  });\n\n  int res = task_mgr-&gt;add_task(co_task, 5, 0);  // add task and setup 5s for timeout\n  if (res &lt; 0) {\n    std::cerr &lt;&lt; \"some error: \" &lt;&lt; res &lt;&lt; std::endl;\n    return res;\n  }\n\n  res = task_mgr-&gt;add_task(co_another_task);  // add task without timeout\n  if (res &lt; 0) {\n    std::cerr &lt;&lt; \"some error: \" &lt;&lt; res &lt;&lt; std::endl;\n    return res;\n  }\n\n  res = task_mgr-&gt;start(co_task-&gt;get_id());\n  if (res &lt; 0) {\n    std::cerr &lt;&lt; \"start task \" &lt;&lt; co_task-&gt;get_id() &lt;&lt; \" failed, error code: \" &lt;&lt; res &lt;&lt; std::endl;\n  }\n\n  res = task_mgr-&gt;start(co_another_task-&gt;get_id());\n  if (res &lt; 0) {\n    std::cerr &lt;&lt; \"start task \" &lt;&lt; co_another_task-&gt;get_id() &lt;&lt; \" failed, error code: \" &lt;&lt; res &lt;&lt; std::endl;\n  }\n\n  res = task_mgr-&gt;resume(co_task-&gt;get_id());\n  if (res &lt; 0) {\n    std::cerr &lt;&lt; \"resume task \" &lt;&lt; co_task-&gt;get_id() &lt;&lt; \" failed, error code: \" &lt;&lt; res &lt;&lt; std::endl;\n  }\n\n  res = task_mgr-&gt;kill(co_another_task-&gt;get_id());\n  if (res &lt; 0) {\n    std::cerr &lt;&lt; \"kill task \" &lt;&lt; co_another_task-&gt;get_id() &lt;&lt; \" failed, error code: \" &lt;&lt; res &lt;&lt; std::endl;\n  } else {\n    std::cout &lt;&lt; \"kill task \" &lt;&lt; co_another_task-&gt;get_id() &lt;&lt; \" finished.\" &lt;&lt; std::endl;\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"examples/#using-stack-pool","title":"Using stack pool","text":"<p>This is a simple example of using stack pool for cotask:</p> <pre><code>#include &lt;inttypes.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n\n// include context header file\n#include &lt;libcopp/stack/stack_pool.h&gt;\n#include &lt;libcotask/task.h&gt;\n\n// define the stack pool type\ntypedef copp::stack_pool&lt;copp::allocator::default_statck_allocator&gt; stack_pool_t;\n\n// define how to create coroutine context\nstruct sample_macro_coroutine {\n  using stack_allocator_type = copp::allocator::stack_allocator_pool&lt;stack_pool_t&gt;;\n  using coroutine_type = copp::coroutine_context_container&lt;stack_allocator_type&gt;;\n  using value_type = int;\n};\n\n// create a stack pool\nstatic stack_pool_t::ptr_t global_stack_pool = stack_pool_t::create();\n\ntypedef cotask::task&lt;sample_macro_coroutine&gt; sample_task_t;\n\nint main() {\n#if defined(LIBCOTASK_MACRO_ENABLED)\n\n  global_stack_pool-&gt;set_min_stack_number(4);\n  std::cout &lt;&lt; \"stack pool=&gt; used stack number: \" &lt;&lt; global_stack_pool-&gt;get_limit().used_stack_number\n            &lt;&lt; \", used stack size: \" &lt;&lt; global_stack_pool-&gt;get_limit().used_stack_size\n            &lt;&lt; \", free stack number: \" &lt;&lt; global_stack_pool-&gt;get_limit().free_stack_number\n            &lt;&lt; \", free stack size: \" &lt;&lt; global_stack_pool-&gt;get_limit().free_stack_size &lt;&lt; std::endl;\n  // create two coroutine task\n  {\n    copp::allocator::stack_allocator_pool&lt;stack_pool_t&gt; alloc(global_stack_pool);\n    sample_task_t::ptr_t co_task = sample_task_t::create(\n        []() {\n          std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;sample_task_t&gt;()-&gt;get_id() &lt;&lt; \" started\" &lt;&lt; std::endl;\n          cotask::this_task::get_task()-&gt;yield();\n          std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;sample_task_t&gt;()-&gt;get_id() &lt;&lt; \" resumed\" &lt;&lt; std::endl;\n          return 0;\n        },\n        alloc);\n\n    if (!co_task) {\n      std::cerr &lt;&lt; \"create coroutine task with stack pool failed\" &lt;&lt; std::endl;\n      return 0;\n    }\n\n    std::cout &lt;&lt; \"stack pool=&gt; used stack number: \" &lt;&lt; global_stack_pool-&gt;get_limit().used_stack_number\n              &lt;&lt; \", used stack size: \" &lt;&lt; global_stack_pool-&gt;get_limit().used_stack_size\n              &lt;&lt; \", free stack number: \" &lt;&lt; global_stack_pool-&gt;get_limit().free_stack_number\n              &lt;&lt; \", free stack size: \" &lt;&lt; global_stack_pool-&gt;get_limit().free_stack_size &lt;&lt; std::endl;\n\n    // ..., then do anything you want to do with these tasks\n  }\n\n  std::cout &lt;&lt; \"stack pool=&gt; used stack number: \" &lt;&lt; global_stack_pool-&gt;get_limit().used_stack_number\n            &lt;&lt; \", used stack size: \" &lt;&lt; global_stack_pool-&gt;get_limit().used_stack_size\n            &lt;&lt; \", free stack number: \" &lt;&lt; global_stack_pool-&gt;get_limit().free_stack_number\n            &lt;&lt; \", free stack size: \" &lt;&lt; global_stack_pool-&gt;get_limit().free_stack_size &lt;&lt; std::endl;\n\n  {\n    copp::allocator::stack_allocator_pool&lt;stack_pool_t&gt; alloc(global_stack_pool);\n    sample_task_t::ptr_t co_another_task = sample_task_t::create(\n        []() {\n          std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;sample_task_t&gt;()-&gt;get_id() &lt;&lt; \" started\" &lt;&lt; std::endl;\n          cotask::this_task::get_task()-&gt;yield();\n          std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;sample_task_t&gt;()-&gt;get_id() &lt;&lt; \" resumed\" &lt;&lt; std::endl;\n          return 0;\n        },\n        alloc);\n\n    if (!co_another_task) {\n      std::cerr &lt;&lt; \"create coroutine task with stack pool failed\" &lt;&lt; std::endl;\n      return 0;\n    }\n\n    // ..., then do anything you want to do with these tasks\n  }\n\n  std::cout &lt;&lt; \"stack pool=&gt; used stack number: \" &lt;&lt; global_stack_pool-&gt;get_limit().used_stack_number\n            &lt;&lt; \", used stack size: \" &lt;&lt; global_stack_pool-&gt;get_limit().used_stack_size\n            &lt;&lt; \", free stack number: \" &lt;&lt; global_stack_pool-&gt;get_limit().free_stack_number\n            &lt;&lt; \", free stack size: \" &lt;&lt; global_stack_pool-&gt;get_limit().free_stack_size &lt;&lt; std::endl;\n#else\n  std::cerr &lt;&lt; \"this sample require cotask enabled.\" &lt;&lt; std::endl;\n#endif\n  return 0;\n}\n</code></pre>"},{"location":"examples/#using-then-or-await_task","title":"Using then or await_task","text":"<p>This is a simple example of using <code>then</code> and <code>await_task</code> for cotask:</p> <pre><code>/*\n * sample_readme_5.cpp\n *\n *  Created on: 2014-05-19\n *      Author: owent\n *\n *  Released under the MIT license\n */\n\n#include &lt;assert.h&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;ctime&gt;\n#include &lt;vector&gt;\n\n#include &lt;libcopp/utils/std/explicit_declare.h&gt;\n\n// include manager header file\n#include &lt;libcotask/task.h&gt;\n\n#if defined(LIBCOTASK_MACRO_ENABLED)\n\ntypedef cotask::task&lt;&gt; my_task_t;\n\nint main() {\n  int test_code = 128;\n\n  // create a task using lambda expression\n  my_task_t::ptr_t first_task = my_task_t::create([&amp;]() {\n    puts(\"|first task running and will be yield ...\");\n    cotask::this_task::get_task()-&gt;yield();\n    puts(\"|first task resumed ...\");\n    printf(\"test code already reset =&gt; %d\\n\", ++test_code);\n  });\n\n  // add many then task using lambda expression\n  first_task\n      -&gt;then([=]() {\n        puts(\"|second task running...\");\n        printf(\"test code should be inited 128 =&gt; %d\\n\", test_code);\n      })\n      -&gt;then([&amp;]() {\n        puts(\"|haha ... this is the third task.\");\n        printf(\"test code is the same =&gt; %d\\n\", ++test_code);\n        return \"return value will be ignored\";\n      })\n      -&gt;then(\n          [&amp;](LIBCOPP_EXPLICIT_UNUSED_ATTR void *priv_data) {\n            puts(\"|it's boring\");\n            printf(\"test code is %d\\n\", ++test_code);\n            assert(&amp;test_code == priv_data);\n            return 0;\n          },\n          &amp;test_code);\n\n  test_code = 0;\n  // start a task\n  first_task-&gt;start();\n  first_task-&gt;resume();\n\n  // these code below will failed.\n  first_task-&gt;then([]() {\n    puts(\"this will run immediately.\");\n    return 0;\n  });\n\n  my_task_t::ptr_t await_task = my_task_t::create([&amp;]() {\n    puts(\"await_task for first_task.\");\n    return 0;\n  });\n  await_task-&gt;await_task(first_task);\n\n  printf(\"|task start twice will failed: %d\\n\", first_task-&gt;start());\n  printf(\"|test_code end with %d\\n\", test_code);\n  return 0;\n}\n#else\nint main() {\n  puts(\"this sample require cotask enabled\");\n  return 0;\n}\n#endif\n</code></pre>"},{"location":"examples/#using-c20-coroutine","title":"Using c++20 coroutine","text":"<pre><code>// Copyright 2026 owent\n// Created by owent on 2022-05-27\n\n#include &lt;iostream&gt;\n\n// include manager header file\n#include &lt;libcopp/coroutine/callable_promise.h&gt;\n\n#if defined(LIBCOPP_MACRO_ENABLE_STD_COROUTINE) &amp;&amp; LIBCOPP_MACRO_ENABLE_STD_COROUTINE\n\nstatic copp::callable_future&lt;int&gt; coroutine_callable_with_int_result() {\n  // ... any code\n  co_return 123;\n}\n\nstatic copp::callable_future&lt;void&gt; coroutine_callable_with_void_result() {\n  // ... any code\n  co_return;\n}\n\nstatic copp::callable_future&lt;void&gt; coroutine_simulator_task() {\n  // suspend and wait custom waker\n  (void)co_await LIBCOPP_MACRO_STD_COROUTINE_NAMESPACE suspend_always();\n  // ... any code\n  // We can get current status by co_yield yield_status()\n  auto current_status = co_yield copp::callable_future&lt;int&gt;::yield_status();\n  // The return value will be ignored when the future is already set by custom waker\n  std::cout &lt;&lt; \"Current coroutine callable status: \" &lt;&lt; static_cast&lt;uint32_t&gt;(current_status) &lt;&lt; std::endl;\n\n  co_await coroutine_callable_with_void_result();\n\n  int result = co_await coroutine_callable_with_int_result();\n  std::cout &lt;&lt; \"Coroutine int callable result: \" &lt;&lt; result &lt;&lt; std::endl;\n  co_return;\n}\n\nint main() {\n  auto rpc_result = coroutine_simulator_task();\n\n  // We should not explict call start and get_internal_handle().resume() in a real usage\n  // It's only allowed to start and resume by co_wait the callable_future object\n  rpc_result.get_internal_handle().resume();  // resume co_await LIBCOPP_MACRO_STD_COROUTINE_NAMESPACE suspend_always();\n\n  std::cout &lt;&lt; \"Current coroutine callable status: \" &lt;&lt; static_cast&lt;uint32_t&gt;(rpc_result.get_status()) &lt;&lt; std::endl;\n  return 0;\n}\n#else\nint main() {\n  puts(\"this sample require cotask enabled and compiler support c++20 coroutine\");\n  return 0;\n}\n#endif\n</code></pre>"},{"location":"examples/#using-c20-coroutine-with-custom-generator","title":"Using c++20 coroutine with custom generator","text":"<pre><code>/*\n * sample_readme_7.cpp\n *\n *  Created on: 2020-05-22\n *      Author: owent\n *\n *  Released under the MIT license\n */\n\n#include &lt;assert.h&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// include manager header file\n#include &lt;libcopp/coroutine/callable_promise.h&gt;\n#include &lt;libcopp/coroutine/generator_promise.h&gt;\n\n#if defined(LIBCOPP_MACRO_ENABLE_STD_COROUTINE) &amp;&amp; LIBCOPP_MACRO_ENABLE_STD_COROUTINE\n\nusing my_generator = copp::generator_future&lt;int&gt;;\nstd::list&lt;my_generator::context_pointer_type&gt; g_sample_executor;\n\nstatic void generator_callback(my_generator::context_pointer_type ctx) {\n  g_sample_executor.emplace_back(std::move(ctx));\n}\n\nstatic copp::callable_future&lt;void&gt; coroutine_simulator_rpc() {\n  my_generator generator_object{generator_callback};\n  auto value1 = co_await generator_object;\n  std::cout &lt;&lt; \"co_await named generator: \" &lt;&lt; value1 &lt;&lt; std::endl;\n  auto value2 = co_await my_generator{generator_callback};\n  std::cout &lt;&lt; \"co_await temporary generator: \" &lt;&lt; value2 &lt;&lt; std::endl;\n\n  generator_object.get_context()-&gt;reset_value();\n  auto value3 = co_await generator_object;\n  std::cout &lt;&lt; \"reset and co_await named generator again: \" &lt;&lt; value3 &lt;&lt; std::endl;\n  co_return;\n}\n\nint main() {\n  int result = 191;\n  auto f = coroutine_simulator_rpc();\n\n  while (!g_sample_executor.empty()) {\n    auto ctx = g_sample_executor.front();\n    g_sample_executor.pop_front();\n    ctx-&gt;set_value(++result);\n  }\n  return 0;\n}\n#else\nint main() {\n  puts(\"this sample require cotask enabled and compiler support c++20 coroutine\");\n  return 0;\n}\n#endif\n</code></pre>"},{"location":"examples/#custom-error-timeout-for-example-for-c20-coroutine","title":"Custom error (timeout for example) for c++20 coroutine","text":"<p>By implementing <code>std_coroutine_default_error_transform&lt;CustomType&gt;</code>, we can transform error code of libcopp to our custom type.</p> <pre><code>/*\n * sample_readme_8.cpp\n *\n *  Created on: 2020-05-20\n *      Author: owent\n *\n *  Released under the MIT license\n */\n\n#include &lt;iostream&gt;\n\n// include manager header file\n#include &lt;libcopp/coroutine/callable_promise.h&gt;\n#include &lt;libcopp/coroutine/generator_promise.h&gt;\n\n#if defined(LIBCOPP_MACRO_ENABLE_STD_COROUTINE) &amp;&amp; LIBCOPP_MACRO_ENABLE_STD_COROUTINE\n\n// ============================ types for task and generator ============================\nclass sample_message_t {\n public:\n  int ret_code;\n\n  sample_message_t() : ret_code(0) {}\n  sample_message_t(int c) : ret_code(c) {}\n  sample_message_t(const sample_message_t &amp;) = default;\n  sample_message_t &amp;operator=(const sample_message_t &amp;) = default;\n  sample_message_t(sample_message_t &amp;&amp;) = default;\n  sample_message_t &amp;operator=(sample_message_t &amp;&amp;) = default;\n  ~sample_message_t() {}\n};\n\n#  define SAMPLE_TIMEOUT_ERROR_CODE (-500)\n\nLIBCOPP_COPP_NAMESPACE_BEGIN\ntemplate &lt;&gt;\nstruct std_coroutine_default_error_transform&lt;sample_message_t&gt; {\n  using type = sample_message_t;\n  type operator()(promise_status in) const {\n    if (in == promise_status::kTimeout) {\n      return sample_message_t{SAMPLE_TIMEOUT_ERROR_CODE};\n    }\n    return sample_message_t{static_cast&lt;int&gt;(in)};\n  }\n};\nLIBCOPP_COPP_NAMESPACE_END\n\nusing int_generator = copp::generator_future&lt;int&gt;;\nstd::list&lt;int_generator::context_pointer_type&gt; g_int_executor;\nusing custom_generator = copp::generator_future&lt;sample_message_t&gt;;\nstd::list&lt;custom_generator::context_pointer_type&gt; g_sample_executor;\n\nstatic void int_generator_callback(int_generator::context_pointer_type ctx) {\n  g_int_executor.emplace_back(std::move(ctx));\n}\n\nstatic void custom_generator_callback(custom_generator::context_pointer_type ctx) {\n  g_sample_executor.emplace_back(std::move(ctx));\n}\n\nstatic copp::callable_future&lt;int&gt; coroutine_simulator_rpc_integer_l2() {\n  auto result = co_await int_generator{int_generator_callback};\n  co_return result;\n}\n\nstatic copp::callable_future&lt;void&gt; coroutine_simulator_rpc_integer() {\n  auto result = co_await coroutine_simulator_rpc_integer_l2();\n  std::cout &lt;&lt; \"int generator is killed with code: \" &lt;&lt; result &lt;&lt; std::endl;\n  co_return;\n}\n\nstatic copp::callable_future&lt;int&gt; coroutine_simulator_rpc_custom_l2() {\n  auto result = co_await custom_generator{custom_generator_callback};\n  co_return result.ret_code;\n}\n\nstatic copp::callable_future&lt;void&gt; coroutine_simulator_rpc_custom() {\n  auto result = co_await coroutine_simulator_rpc_custom_l2();\n  std::cout &lt;&lt; \"custom generator is killed with code: \" &lt;&lt; result &lt;&lt; std::endl;\n  co_return;\n}\n\nint main() {\n  // sample for await generator and timeout\n  auto f1 = coroutine_simulator_rpc_integer();\n  f1.kill(copp::promise_status::kCancle, true);\n  std::cout &lt;&lt; \"int generator is killed\" &lt;&lt; std::endl;\n\n  // sample for await task and timeout\n  auto f2 = coroutine_simulator_rpc_custom();\n  f2.kill(copp::promise_status::kTimeout, true);\n  std::cout &lt;&lt; \"custom generator is killed\" &lt;&lt; std::endl;\n  return 0;\n}\n#else\nint main() {\n  puts(\"this sample require cotask enabled and compiler support c++20 coroutine\");\n  return 0;\n}\n#endif\n</code></pre>"},{"location":"examples/#let-c20-coroutine-work-with-cotasktask","title":"Let c++20 coroutine work with cotask::task <p>This is a simple example to let c++20 coroutine await cotask::task.</p> <pre><code>/*\n * sample_readme_9.cpp\n *\n *  Created on: 2020-05-20\n *      Author: owent\n *\n *  Released under the MIT license\n */\n\n#include &lt;iostream&gt;\n\n// include manager header file\n#include &lt;libcopp/coroutine/callable_promise.h&gt;\n#include &lt;libcotask/task.h&gt;\n\n#if defined(LIBCOPP_MACRO_ENABLE_STD_COROUTINE) &amp;&amp; LIBCOPP_MACRO_ENABLE_STD_COROUTINE\n\ntypedef cotask::task&lt;&gt; my_task_t;\n\nstatic copp::callable_future&lt;int&gt; call_for_await_cotask(my_task_t::ptr_t t) {\n  if (t) {\n    auto ret = co_await t;\n    co_return ret;\n  }\n\n  co_return 0;\n}\n\nstatic int cotask_action_callback(void*) {\n  int ret = 234;\n  void* ptr = nullptr;\n  cotask::this_task::get_task()-&gt;yield(&amp;ptr);\n  if (ptr != nullptr) {\n    ret = *reinterpret_cast&lt;int*&gt;(ptr);\n  }\n  return ret;\n}\n\nint main() {\n  my_task_t::ptr_t co_task = my_task_t::create(cotask_action_callback);\n\n  auto t = call_for_await_cotask(co_task);\n  co_task-&gt;start();\n\n  int res = 345;\n  co_task-&gt;resume(reinterpret_cast&lt;void*&gt;(&amp;res));\n\n  std::cout &lt;&lt; \"co_await a cotask::task and get result: \" &lt;&lt; t.get_internal_promise().data() &lt;&lt; std::endl;\n  return 0;\n}\n#else\nint main() {\n  puts(\"this sample require cotask enabled and compiler support c++20 coroutine\");\n  return 0;\n}\n#endif\n</code></pre>","text":""},{"location":"examples/#using-setunhandledexceptionfilter-on-windows-with-cotasktask","title":"Using SetUnhandledExceptionFilter on Windows with cotask::task <p>Some applications will use <code>SetUnhandledExceptionFilter</code> to catch unhandled exception and analysis crash problem. But <code>SetUnhandledExceptionFilter</code> is only works with coroutine context of windows fiber. This is a sample of using windows fiber as coroutine context in <code>cotask::task&lt;MACRO&gt;</code>.</p> <pre><code>#include &lt;iostream&gt;\n\n#include &lt;libcopp/utils/config/libcopp_build_features.h&gt;\n\n#if (defined(LIBCOTASK_MACRO_ENABLED) &amp;&amp; LIBCOTASK_MACRO_ENABLED) &amp;&amp; defined(LIBCOPP_MACRO_ENABLE_WIN_FIBER) &amp;&amp; \\\n    LIBCOPP_MACRO_ENABLE_WIN_FIBER\n// include task header file\n#  include &lt;libcotask/task.h&gt;\n\nstruct my_task_macro_t {\n  using stack_allocator_type = copp::coroutine_fiber_context_default::allocator_type;\n  using coroutine_type = copp::coroutine_fiber_context_default;\n  using value_type = int;\n};\n\ntypedef cotask::task&lt;my_task_macro_t&gt; my_task_t;\n\n#  ifdef _MSC_VER\n#    pragma warning(push)\n#    pragma warning(disable : 4091)\n\n#    include &lt;atlconv.h&gt;\n#    include &lt;imagehlp.h&gt;\n\n#    pragma comment(lib, \"dbghelp.lib\")\n\n#    ifdef UNICODE\n#      define SAMPLE_VC_TEXT(x) A2W(x)\n#    else\n#      define SAMPLE_VC_TEXT(x) x\n#    endif\n\nLPTOP_LEVEL_EXCEPTION_FILTER g_msvc_debuger_old_handle = nullptr;\nstd::string g_msvc_debuger_pattern;\n\ninline void CreateMiniDump(EXCEPTION_POINTERS *pep, LPCTSTR strFileName) {\n  HANDLE hFile =\n      CreateFile(strFileName, GENERIC_READ | GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);\n\n  if ((hFile != nullptr) &amp;&amp; (hFile != INVALID_HANDLE_VALUE)) {\n    MINIDUMP_EXCEPTION_INFORMATION mdei;\n    mdei.ThreadId = GetCurrentThreadId();\n    mdei.ExceptionPointers = pep;\n    mdei.ClientPointers = FALSE;\n    // MINIDUMP_CALLBACK_INFORMATION mci;\n    // mci.CallbackRoutine = (MINIDUMP_CALLBACK_ROUTINE)MiniDumpCallback;\n    // mci.CallbackParam = 0;\n    MINIDUMP_TYPE mdt =\n        (MINIDUMP_TYPE)(MiniDumpWithPrivateReadWriteMemory | MiniDumpWithDataSegs | MiniDumpWithHandleData |\n                        MiniDumpWithFullMemoryInfo | MiniDumpWithThreadInfo | MiniDumpWithUnloadedModules);\n    MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, mdt, (pep != 0) ? &amp;mdei : 0, 0, nullptr);\n    CloseHandle(hFile);\n  }\n}\n\nLONG WINAPI GPTUnhandledExceptionFilter(PEXCEPTION_POINTERS pExceptionInfo) {\n  // \u5f97\u5230\u5f53\u524d\u65f6\u95f4\n  SYSTEMTIME st;\n  ::GetLocalTime(&amp;st);\n  // \u5f97\u5230\u7a0b\u5e8f\u6240\u5728\u6587\u4ef6\u5939\n  //  TCHAR exeFullPath[256]; // MAX_PATH\n  //  GetModuleFileName(nullptr, exeFullPath, 256);//\u5f97\u5230\u7a0b\u5e8f\u6a21\u5757\u540d\u79f0\uff0c\u5168\u8def\u5f84\n\n  TCHAR szFileName[_MAX_FNAME] = {0};\n\n  USES_CONVERSION;\n\n  wsprintf(szFileName, TEXT(\"%s-%04d-%02d-%02d.%02d%02d%02d.%03d.dmp\"), SAMPLE_VC_TEXT(g_msvc_debuger_pattern.c_str()),\n           st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\n  CreateMiniDump(pExceptionInfo, szFileName);\n\n  if (nullptr == g_msvc_debuger_old_handle) {\n    return EXCEPTION_EXECUTE_HANDLER;  // \u4e0b\u4e00\u4e2aHandle, \u4e00\u822c\u662f\u7a0b\u5e8f\u505c\u6b62\u8fd0\u884c\n  }\n\n  return g_msvc_debuger_old_handle(pExceptionInfo);\n}\n\nvoid __cdecl sample_setup_msvc_mini_dump(const char *prefix) {\n  g_msvc_debuger_pattern = prefix;\n  g_msvc_debuger_old_handle = SetUnhandledExceptionFilter(GPTUnhandledExceptionFilter);\n  if (g_msvc_debuger_old_handle == GPTUnhandledExceptionFilter) {\n    g_msvc_debuger_old_handle = nullptr;\n  }\n}\n#  endif\n\nint main() {\n#  ifdef _MSC_VER\n  sample_setup_msvc_mini_dump(\"d:/libcopp-test-minidump\");\n#  endif\n  // create a task using factory function [with lambda expression]\n  my_task_t::ptr_t task = my_task_t::create([]() {\n    std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" started\" &lt;&lt; std::endl;\n    cotask::this_task::get_task()-&gt;yield();\n    std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" resumed\" &lt;&lt; std::endl;\n\n    // ! Make crash and it's will generate a mini dump into d:/libcopp-test-minidump-*.dmp\n    // copp::this_coroutine::get_coroutine()-&gt;yield();\n    return 0;\n  });\n\n  std::cout &lt;&lt; \"task \" &lt;&lt; task-&gt;get_id() &lt;&lt; \" created\" &lt;&lt; std::endl;\n  // start a task\n  task-&gt;start();\n\n  std::cout &lt;&lt; \"task \" &lt;&lt; task-&gt;get_id() &lt;&lt; \" yield\" &lt;&lt; std::endl;\n  task-&gt;resume();\n  std::cout &lt;&lt; \"task \" &lt;&lt; task-&gt;get_id() &lt;&lt; \" stoped, ready to be destroyed.\" &lt;&lt; std::endl;\n\n  return 0;\n}\n\n#  ifdef _MSC_VER\n#    pragma warning(pop)\n#  endif\n\n#else\nint main() {\n  std::cerr &lt;&lt; \"lambda not supported, or fiber is not supported, this sample is not available.\" &lt;&lt; std::endl;\n  return 0;\n}\n#endif\n</code></pre>","text":""},{"location":"examples/#using-c20-coroutine-with-channel-receiver-and-sender","title":"Using c++20 coroutine with channel receiver and sender <pre><code>/*\n * sample_readme_11.cpp\n *\n *  Created on: 2025-03-04\n *      Author: owent\n *\n *  Released under the MIT license\n */\n\n#include &lt;assert.h&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// include manager header file\n#include &lt;libcopp/coroutine/callable_promise.h&gt;\n#include &lt;libcopp/coroutine/generator_promise.h&gt;\n\n#if defined(LIBCOPP_MACRO_ENABLE_STD_COROUTINE) &amp;&amp; LIBCOPP_MACRO_ENABLE_STD_COROUTINE\n\nusing my_receiver = copp::generator_channel_receiver&lt;int&gt;;\nusing my_sender = copp::generator_channel_sender&lt;int&gt;;\nstd::list&lt;my_sender&gt; g_sample_executor;\n\nstatic my_receiver generator_pick_receiver(std::pair&lt;my_receiver, my_sender&gt;&amp;&amp; receiver_and_sender) {\n  g_sample_executor.emplace_back(std::move(receiver_and_sender.second));\n  return receiver_and_sender.first;\n}\n\nstatic copp::callable_future&lt;void&gt; coroutine_simulator_rpc() {\n  my_receiver my_generator = generator_pick_receiver(copp::make_channel&lt;int&gt;());\n\n  auto value1 = co_await my_generator;\n  std::cout &lt;&lt; \"co_await named channel receiver: \" &lt;&lt; value1 &lt;&lt; std::endl;\n  auto value2 = co_await generator_pick_receiver(copp::make_channel&lt;int&gt;());\n  std::cout &lt;&lt; \"co_await temporary channel receiver: \" &lt;&lt; value2 &lt;&lt; std::endl;\n\n  co_return;\n}\n\nint main() {\n  int result = 191;\n  auto f = coroutine_simulator_rpc();\n\n  while (!g_sample_executor.empty()) {\n    auto ctx = g_sample_executor.front();\n    g_sample_executor.pop_front();\n    ctx-&gt;set_value(++result);\n  }\n  return 0;\n}\n#else\nint main() {\n  puts(\"this sample require cotask enabled and compiler support c++20 coroutine\");\n  return 0;\n}\n#endif\n</code></pre>","text":""},{"location":"examples/#using-stackful-coroutine-task-with-channel-receiver-and-sender","title":"Using stackful coroutine task with channel receiver and sender <pre><code>/*\n * sample_readme_12.cpp\n *\n *  Created on: 2025-03-05\n *      Author: owent\n *\n *  Released under the MIT license\n */\n\n#include &lt;iostream&gt;\n\n// include task header file\n#include &lt;libcopp/coroutine/stackful_channel.h&gt;\n#include &lt;libcotask/task.h&gt;\n\ntypedef cotask::task&lt;&gt; my_task_t;\n\nint main() {\n  // Returns &lt;receiver, sender&gt;\n  auto channel = copp::make_stackful_channel&lt;int&gt;();\n  // Create a task and use channel to receive data\n  {\n    my_task_t::ptr_t task = my_task_t::create([&amp;channel]() {\n      std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" started\" &lt;&lt; std::endl;\n      auto receiver = channel.first;\n      int value = cotask::this_task::get&lt;my_task_t&gt;()-&gt;await_value(receiver);\n      std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" resumed, got value: \" &lt;&lt; value\n                &lt;&lt; std::endl;\n      return 0;\n    });\n\n    task-&gt;start();\n    channel.second.set_value(42);\n  }\n\n  // Use channel and custom transform function to receive error\n  channel.first.reset_value();\n  {\n    my_task_t::ptr_t task = my_task_t::create([&amp;channel]() {\n      std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" started\" &lt;&lt; std::endl;\n      auto receiver = channel.first;\n      int value = cotask::this_task::get&lt;my_task_t&gt;()-&gt;await_value(receiver, [](copp::copp_error_code) { return -5; });\n      std::cout &lt;&lt; \"task \" &lt;&lt; cotask::this_task::get&lt;my_task_t&gt;()-&gt;get_id() &lt;&lt; \" resumed, got value: \" &lt;&lt; value\n                &lt;&lt; std::endl;\n      return 0;\n    });\n\n    task-&gt;start();\n    task-&gt;kill();\n  }\n\n  return 0;\n}\n</code></pre>","text":""},{"location":"examples/#using-stackful-coroutine-with-channel-receiver-and-sender","title":"Using stackful coroutine with channel receiver and sender <p>This example demonstrates the channel/receiver pattern with stackful coroutines, including:</p> <ul> <li>Basic producer/consumer communication</li> <li>Error handling with custom transforms  </li> <li>Direct usage with <code>copp::coroutine_context</code></li> </ul> <pre><code>// Copyright 2026 owent\n// Sample code for stackful coroutine channel/receiver model\n\n#include &lt;libcopp/coroutine/coroutine_context_container.h&gt;\n#include &lt;libcopp/coroutine/stackful_channel.h&gt;\n#include &lt;libcotask/task.h&gt;\n\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\n// ===============================================\n// Example 1: Basic Channel Usage with cotask::task\n// ===============================================\n\nclass producer_action : public cotask::impl::task_action_impl {\n public:\n  producer_action(copp::stackful_channel_sender&lt;int&gt; sender) : sender_(std::move(sender)), value_to_send_(0) {}\n\n  int operator()(void*) override {\n    std::cout &lt;&lt; \"[Producer] Starting production...\" &lt;&lt; std::endl;\n\n    // Simulate producing values\n    for (int i = 1; i &lt;= 5; ++i) {\n      value_to_send_ = i * 100;\n      std::cout &lt;&lt; \"[Producer] Producing value: \" &lt;&lt; value_to_send_ &lt;&lt; std::endl;\n\n      // Send value through channel\n      sender_.set_value(value_to_send_);\n\n      std::cout &lt;&lt; \"[Producer] Value sent, yielding...\" &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"[Producer] Production complete!\" &lt;&lt; std::endl;\n    return 0;\n  }\n\n private:\n  copp::stackful_channel_sender&lt;int&gt; sender_;\n  int value_to_send_;\n};\n\nclass consumer_action : public cotask::impl::task_action_impl {\n public:\n  consumer_action(copp::stackful_channel_receiver&lt;int&gt; receiver) : receiver_(std::move(receiver)) {}\n\n  int operator()(void*) override {\n    std::cout &lt;&lt; \"[Consumer] Starting consumption...\" &lt;&lt; std::endl;\n\n    // Receive values from channel\n    for (int i = 1; i &lt;= 5; ++i) {\n      std::cout &lt;&lt; \"[Consumer] Waiting for value \" &lt;&lt; i &lt;&lt; \"...\" &lt;&lt; std::endl;\n\n      // await_value will suspend the task until a value is available\n      int value = cotask::task&lt;&gt;::this_task()-&gt;await_value(receiver_);\n\n      std::cout &lt;&lt; \"[Consumer] Received value: \" &lt;&lt; value &lt;&lt; std::endl;\n\n      // Reset channel for next value\n      receiver_.reset_value();\n    }\n\n    std::cout &lt;&lt; \"[Consumer] Consumption complete!\" &lt;&lt; std::endl;\n    return 0;\n  }\n\n private:\n  copp::stackful_channel_receiver&lt;int&gt; receiver_;\n};\n\nvoid example_basic_channel() {\n  std::cout &lt;&lt; \"\\n========== Example 1: Basic Channel Usage ==========\\n\" &lt;&lt; std::endl;\n\n  // Create a channel for int communication\n  std::pair&lt;copp::stackful_channel_receiver&lt;int&gt;, copp::stackful_channel_sender&lt;int&gt;&gt; channel =\n      copp::make_stackful_channel&lt;int&gt;();\n  auto receiver = std::move(channel.first);\n  auto sender = std::move(channel.second);\n\n  // Create consumer and producer tasks\n  auto consumer = cotask::task&lt;&gt;::create(consumer_action(std::move(receiver)));\n  auto producer = cotask::task&lt;&gt;::create(producer_action(std::move(sender)));\n\n  // Start consumer (it will suspend immediately waiting for data)\n  std::cout &lt;&lt; \"Starting consumer task...\" &lt;&lt; std::endl;\n  consumer-&gt;start();\n\n  std::cout &lt;&lt; \"\\nStarting producer task...\" &lt;&lt; std::endl;\n  producer-&gt;start();\n\n  std::cout &lt;&lt; \"\\nBoth tasks completed!\" &lt;&lt; std::endl;\n}\n\n// ===============================================\n// Example 2: Error Handling with Custom Transform\n// ===============================================\n\nclass consumer_with_error_handling : public cotask::impl::task_action_impl {\n public:\n  consumer_with_error_handling(copp::stackful_channel_receiver&lt;int&gt; receiver) : receiver_(std::move(receiver)) {}\n\n  int operator()(void*) override {\n    std::cout &lt;&lt; \"[Consumer] Starting with error handling...\" &lt;&lt; std::endl;\n\n    // First receive with default error handling\n    {\n      int value = cotask::task&lt;&gt;::this_task()-&gt;await_value(receiver_);\n      std::cout &lt;&lt; \"[Consumer] Received: \" &lt;&lt; value &lt;&lt; std::endl;\n      receiver_.reset_value();\n    }\n\n    // Second receive with custom error transform\n    {\n      auto error_transform = [](copp::copp_error_code err) {\n        std::cout &lt;&lt; \"[Consumer] Error occurred: \" &lt;&lt; static_cast&lt;int&gt;(err) &lt;&lt; \", returning default value -1\"\n                  &lt;&lt; std::endl;\n        return -1;  // Return default value on error\n      };\n\n      int value = cotask::task&lt;&gt;::this_task()-&gt;await_value(receiver_, error_transform);\n      std::cout &lt;&lt; \"[Consumer] Received or defaulted: \" &lt;&lt; value &lt;&lt; std::endl;\n    }\n\n    return 0;\n  }\n\n private:\n  copp::stackful_channel_receiver&lt;int&gt; receiver_;\n};\n\nvoid example_error_handling() {\n  std::cout &lt;&lt; \"\\n========== Example 2: Error Handling ==========\\n\" &lt;&lt; std::endl;\n\n  std::pair&lt;copp::stackful_channel_receiver&lt;int&gt;, copp::stackful_channel_sender&lt;int&gt;&gt; channel =\n      copp::make_stackful_channel&lt;int&gt;();\n  auto receiver = std::move(channel.first);\n  auto sender = std::move(channel.second);\n\n  auto consumer = cotask::task&lt;&gt;::create(consumer_with_error_handling(std::move(receiver)));\n\n  consumer-&gt;start();\n\n  // Send first value normally\n  sender.set_value(42);\n\n  // Kill the consumer task to trigger error handling\n  std::cout &lt;&lt; \"\\nKilling consumer task to demonstrate error handling...\" &lt;&lt; std::endl;\n  consumer-&gt;kill();\n\n  std::cout &lt;&lt; \"\\nTask killed!\" &lt;&lt; std::endl;\n}\n\n// ===============================================\n// Example 3: Using with copp::coroutine_context directly\n// ===============================================\n\nstruct direct_context_example_data {\n  copp::stackful_channel_receiver&lt;int&gt; receiver;\n  int received_sum = 0;\n};\n\nint direct_consumer_runner(void* data_ptr) {\n  auto* data = static_cast&lt;direct_context_example_data*&gt;(data_ptr);\n\n  std::cout &lt;&lt; \"[Direct Consumer] Starting...\" &lt;&lt; std::endl;\n\n  // Use inject_await with error transform for low-level control\n  auto error_transform = [](copp::copp_error_code err) {\n    std::cout &lt;&lt; \"[Direct Consumer] Error: \" &lt;&lt; static_cast&lt;int&gt;(err) &lt;&lt; std::endl;\n    return 0;\n  };\n\n  for (int i = 0; i &lt; 3; ++i) {\n    // Get current coroutine context\n    auto* ctx = copp::this_coroutine::get&lt;copp::coroutine_context&gt;();\n\n    std::cout &lt;&lt; \"[Direct Consumer] Awaiting value \" &lt;&lt; (i + 1) &lt;&lt; \"...\" &lt;&lt; std::endl;\n\n    // Directly use inject_await on receiver\n    int value = data-&gt;receiver.inject_await(ctx, error_transform);\n\n    std::cout &lt;&lt; \"[Direct Consumer] Received: \" &lt;&lt; value &lt;&lt; std::endl;\n    data-&gt;received_sum += value;\n\n    data-&gt;receiver.reset_value();\n  }\n\n  std::cout &lt;&lt; \"[Direct Consumer] Total sum: \" &lt;&lt; data-&gt;received_sum &lt;&lt; std::endl;\n  return 0;\n}\n\nvoid example_direct_coroutine_context() {\n  std::cout &lt;&lt; \"\\n========== Example 4: Direct Coroutine Context Usage ==========\\n\" &lt;&lt; std::endl;\n\n  std::pair&lt;copp::stackful_channel_receiver&lt;int&gt;, copp::stackful_channel_sender&lt;int&gt;&gt; channel =\n      copp::make_stackful_channel&lt;int&gt;();\n  auto receiver = std::move(channel.first);\n  auto sender = std::move(channel.second);\n\n  direct_context_example_data data;\n  data.receiver = std::move(receiver);\n\n  // Create coroutine context directly\n  typedef copp::coroutine_context_container&lt;copp::allocator::stack_allocator_malloc&gt; coroutine_t;\n\n  coroutine_t::ptr_t co = coroutine_t::create(direct_consumer_runner);\n\n  std::cout &lt;&lt; \"Starting direct coroutine...\" &lt;&lt; std::endl;\n  co-&gt;start(&amp;data);\n\n  // Send values\n  for (int value : {10, 20, 30}) {\n    std::cout &lt;&lt; \"\\nSending value: \" &lt;&lt; value &lt;&lt; std::endl;\n    sender.set_value(value);\n  }\n\n  std::cout &lt;&lt; \"\\nDirect coroutine completed with sum: \" &lt;&lt; data.received_sum &lt;&lt; std::endl;\n}\n\n// ===============================================\n// Main\n// ===============================================\n\nint main() {\n#if defined(LIBCOTASK_MACRO_ENABLED)\n  example_basic_channel();\n  example_error_handling();\n  example_direct_coroutine_context();\n\n  std::cout &lt;&lt; \"\\n========== All Examples Completed! ==========\\n\" &lt;&lt; std::endl;\n#else\n  std::cerr &lt;&lt; \"libcotask is not enabled, sample is disabled\" &lt;&lt; std::endl;\n#endif\n  return 0;\n}\n</code></pre> <p>For detailed documentation on channels, see the Channels Guide.</p>","text":""},{"location":"examples/#using-c20-coroutine-with-channel-receiver-and-sender_1","title":"Using C++20 coroutine with channel receiver and sender <p>This example demonstrates the channel/receiver pattern with C++20 coroutines, including:</p> <ul> <li>Basic channel usage with <code>co_await</code></li> <li>Producer/consumer pattern</li> <li>Error handling with custom error transforms</li> <li>Void channels for signaling</li> <li>Comparison of generator vtable types</li> </ul> <pre><code>// Copyright 2026 owent\n// Sample code for C++20 coroutine channel/receiver model\n\n#include &lt;libcopp/coroutine/callable_promise.h&gt;\n#include &lt;libcopp/coroutine/generator_promise.h&gt;\n\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\n#if defined(LIBCOPP_MACRO_ENABLE_STD_COROUTINE) &amp;&amp; LIBCOPP_MACRO_ENABLE_STD_COROUTINE\n\ntemplate &lt;class TReceiver&gt;\nstatic inline void reset_channel_value(TReceiver&amp; receiver) {\n  auto ctx = receiver.get_context();\n  if (ctx) {\n    ctx-&gt;reset_value();\n  }\n}\n\n// ===============================================\n// Example 1: Basic Channel Usage with C++20 Coroutine\n// ===============================================\n\ncopp::callable_future&lt;int&gt; basic_consumer(copp::generator_channel_receiver&lt;int&gt; receiver) {\n  std::cout &lt;&lt; \"[Consumer] Waiting for first value...\" &lt;&lt; std::endl;\n\n  // Use co_await to receive value from channel\n  int value1 = co_await receiver;\n  std::cout &lt;&lt; \"[Consumer] Received first value: \" &lt;&lt; value1 &lt;&lt; std::endl;\n\n  // Must reset to receive next value\n  reset_channel_value(receiver);\n\n  std::cout &lt;&lt; \"[Consumer] Waiting for second value...\" &lt;&lt; std::endl;\n  int value2 = co_await receiver;\n  std::cout &lt;&lt; \"[Consumer] Received second value: \" &lt;&lt; value2 &lt;&lt; std::endl;\n\n  reset_channel_value(receiver);\n\n  std::cout &lt;&lt; \"[Consumer] Waiting for third value...\" &lt;&lt; std::endl;\n  int value3 = co_await receiver;\n  std::cout &lt;&lt; \"[Consumer] Received third value: \" &lt;&lt; value3 &lt;&lt; std::endl;\n\n  co_return value1 + value2 + value3;\n}\n\nvoid example_basic_channel() {\n  std::cout &lt;&lt; \"\\n========== Example 1: Basic C++20 Channel Usage ==========\\n\" &lt;&lt; std::endl;\n\n  // Create a channel for int communication\n  auto [receiver, sender] = copp::make_channel&lt;int&gt;();\n\n  // Start consumer coroutine\n  std::cout &lt;&lt; \"Starting consumer coroutine...\" &lt;&lt; std::endl;\n  auto consumer_future = basic_consumer(std::move(receiver));\n\n  std::cout &lt;&lt; \"\\nConsumer is now waiting for values...\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Is consumer ready? \" &lt;&lt; (consumer_future.is_ready() ? \"Yes\" : \"No\") &lt;&lt; std::endl;\n\n  // Send values through sender\n  std::cout &lt;&lt; \"\\nSending first value: 10\" &lt;&lt; std::endl;\n  sender-&gt;set_value(10);\n\n  std::cout &lt;&lt; \"\\nSending second value: 20\" &lt;&lt; std::endl;\n  sender-&gt;set_value(20);\n\n  std::cout &lt;&lt; \"\\nSending third value: 30\" &lt;&lt; std::endl;\n  sender-&gt;set_value(30);\n\n  std::cout &lt;&lt; \"\\nConsumer completed with sum: \" &lt;&lt; consumer_future.get_internal_promise().data() &lt;&lt; std::endl;\n}\n\n// ===============================================\n// Example 2: Producer/Consumer Pattern\n// ===============================================\n\ncopp::callable_future&lt;void&gt; producer_coroutine(copp::generator_channel_sender&lt;int&gt; sender, int count) {\n  std::cout &lt;&lt; \"[Producer] Starting to produce \" &lt;&lt; count &lt;&lt; \" values...\" &lt;&lt; std::endl;\n\n  for (int i = 1; i &lt;= count; ++i) {\n    int value = i * 100;\n    std::cout &lt;&lt; \"[Producer] Producing value \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; value &lt;&lt; std::endl;\n\n    // Send value to channel\n    sender-&gt;set_value(value);\n\n    // Yield to let consumer process\n    auto current_status = co_yield copp::callable_future&lt;void&gt;::yield_status();\n    (void)current_status;\n  }\n\n  std::cout &lt;&lt; \"[Producer] Production complete!\" &lt;&lt; std::endl;\n  co_return;\n}\n\ncopp::callable_future&lt;int&gt; consumer_coroutine(copp::generator_channel_receiver&lt;int&gt; receiver, int count) {\n  std::cout &lt;&lt; \"[Consumer] Starting to consume \" &lt;&lt; count &lt;&lt; \" values...\" &lt;&lt; std::endl;\n\n  int sum = 0;\n  for (int i = 1; i &lt;= count; ++i) {\n    std::cout &lt;&lt; \"[Consumer] Waiting for value \" &lt;&lt; i &lt;&lt; \"...\" &lt;&lt; std::endl;\n\n    int value = co_await receiver;\n    std::cout &lt;&lt; \"[Consumer] Received value \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; value &lt;&lt; std::endl;\n\n    sum += value;\n    reset_channel_value(receiver);\n  }\n\n  std::cout &lt;&lt; \"[Consumer] Consumption complete! Total sum: \" &lt;&lt; sum &lt;&lt; std::endl;\n  co_return sum;\n}\n\nvoid example_producer_consumer() {\n  std::cout &lt;&lt; \"\\n========== Example 2: Producer/Consumer Pattern ==========\\n\" &lt;&lt; std::endl;\n\n  auto [receiver, sender] = copp::make_channel&lt;int&gt;();\n\n  // Start both producer and consumer\n  auto consumer = consumer_coroutine(std::move(receiver), 5);\n  auto producer = producer_coroutine(sender, 5);\n\n  std::cout &lt;&lt; \"\\nBoth coroutines completed!\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Final sum: \" &lt;&lt; consumer.get_internal_promise().data() &lt;&lt; std::endl;\n}\n\n// ===============================================\n// Example 3: Error Handling\n// ===============================================\n\nstruct custom_error_transform {\n  int operator()(copp::promise_status status) const {\n    if (status == copp::promise_status::kKilled) {\n      std::cout &lt;&lt; \"[Error Transform] Coroutine was killed, returning -999\" &lt;&lt; std::endl;\n      return -999;\n    } else if (status == copp::promise_status::kTimeout) {\n      std::cout &lt;&lt; \"[Error Transform] Timeout occurred, returning -888\" &lt;&lt; std::endl;\n      return -888;\n    }\n    std::cout &lt;&lt; \"[Error Transform] Other error: \" &lt;&lt; static_cast&lt;int&gt;(status) &lt;&lt; \", returning -1\" &lt;&lt; std::endl;\n    return -1;\n  }\n};\n\ncopp::callable_future&lt;int&gt; consumer_with_error_handling(\n    copp::generator_channel_receiver&lt;int, custom_error_transform&gt; receiver) {\n  std::cout &lt;&lt; \"[Consumer] Waiting for value (with custom error handling)...\" &lt;&lt; std::endl;\n\n  // This will use custom_error_transform if an error occurs\n  int value = co_await receiver;\n\n  std::cout &lt;&lt; \"[Consumer] Received value or error default: \" &lt;&lt; value &lt;&lt; std::endl;\n  co_return value;\n}\n\nvoid example_error_handling() {\n  std::cout &lt;&lt; \"\\n========== Example 3: Error Handling with Custom Transform ==========\\n\" &lt;&lt; std::endl;\n\n  auto [receiver, sender] = copp::make_channel&lt;int, custom_error_transform&gt;();\n\n  auto consumer = consumer_with_error_handling(std::move(receiver));\n\n  std::cout &lt;&lt; \"\\nKilling consumer to demonstrate error handling...\" &lt;&lt; std::endl;\n  consumer.kill(copp::promise_status::kKilled, true);\n\n  std::cout &lt;&lt; \"Consumer result after kill: \" &lt;&lt; consumer.get_internal_promise().data() &lt;&lt; std::endl;\n}\n\n// ===============================================\n// Example 4: Void Channel\n// ===============================================\n\ncopp::callable_future&lt;void&gt; void_channel_consumer(copp::generator_channel_receiver&lt;void&gt; receiver) {\n  std::cout &lt;&lt; \"[Consumer] Waiting for signal 1...\" &lt;&lt; std::endl;\n  co_await receiver;\n  std::cout &lt;&lt; \"[Consumer] Received signal 1!\" &lt;&lt; std::endl;\n\n  reset_channel_value(receiver);\n\n  std::cout &lt;&lt; \"[Consumer] Waiting for signal 2...\" &lt;&lt; std::endl;\n  co_await receiver;\n  std::cout &lt;&lt; \"[Consumer] Received signal 2!\" &lt;&lt; std::endl;\n\n  reset_channel_value(receiver);\n\n  std::cout &lt;&lt; \"[Consumer] Waiting for signal 3...\" &lt;&lt; std::endl;\n  co_await receiver;\n  std::cout &lt;&lt; \"[Consumer] Received signal 3!\" &lt;&lt; std::endl;\n\n  co_return;\n}\n\nvoid example_void_channel() {\n  std::cout &lt;&lt; \"\\n========== Example 4: Void Channel (Signaling) ==========\\n\" &lt;&lt; std::endl;\n\n  auto [receiver, sender] = copp::make_channel&lt;void&gt;();\n\n  auto consumer = void_channel_consumer(std::move(receiver));\n\n  std::cout &lt;&lt; \"\\nSending signal 1...\" &lt;&lt; std::endl;\n  sender-&gt;set_value();\n\n  std::cout &lt;&lt; \"\\nSending signal 2...\" &lt;&lt; std::endl;\n  sender-&gt;set_value();\n\n  std::cout &lt;&lt; \"\\nSending signal 3...\" &lt;&lt; std::endl;\n  sender-&gt;set_value();\n\n  std::cout &lt;&lt; \"\\nConsumer completed!\" &lt;&lt; std::endl;\n}\n\n// ===============================================\n// Example 5: Comparison of Generator Future Types\n// ===============================================\n\nvoid example_vtable_types() {\n  std::cout &lt;&lt; \"\\n========== Example 5: Generator VTable Types ==========\\n\" &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; \"libcopp provides three generator vtable types:\\n\" &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; \"1. generator_vtable_type::kDefault\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - Uses std::function for callbacks (most flexible)\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - Can capture complex state in lambdas\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - Type: copp::generator_future&lt;T&gt;\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - Best for: Complex scenarios with stateful callbacks\\n\" &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; \"2. generator_vtable_type::kLightWeight\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - Uses function pointers instead of std::function\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - Lower overhead, faster performance\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - Type: copp::generator_lightweight_future&lt;T&gt;\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - Best for: Performance-critical code with simple callbacks\\n\" &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; \"3. generator_vtable_type::kNone\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - No callbacks, designed for channel/receiver pattern\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - Minimal overhead, most efficient\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - Type: copp::generator_channel_future&lt;T&gt; (used by make_channel)\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"   - Best for: Channel-based communication between coroutines\\n\" &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; \"Recommendation:\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"  - For channels: Use make_channel() (kNone vtable)\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"  - For simple futures: Use generator_lightweight_future (kLightWeight)\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"  - For complex futures: Use generator_future (kDefault)\\n\" &lt;&lt; std::endl;\n}\n\n// ===============================================\n// Main\n// ===============================================\n\nint main() {\n  example_basic_channel();\n  example_producer_consumer();\n  example_error_handling();\n  example_void_channel();\n  example_vtable_types();\n\n  std::cout &lt;&lt; \"\\n========== All C++20 Channel Examples Completed! ==========\\n\" &lt;&lt; std::endl;\n  return 0;\n}\n\n#else\n\nint main() {\n  std::cerr &lt;&lt; \"C++20 coroutine is not enabled, sample is disabled\" &lt;&lt; std::endl;\n  return 0;\n}\n\n#endif\n</code></pre> <p>For detailed documentation on channels, see the Channels Guide.</p>","text":""},{"location":"reference/","title":"Reference","text":"<p>Auto generated API document can be found at: https://libcopp.atframe.work/doxygen/html/</p>"}]}